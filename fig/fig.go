// Code generated by github.com/heyvito/gokiwi. DO NOT EDIT.

package fig

import "github.com/heyvito/gokiwi"

type MessageType int

const (
	MessageTypeJoinStart                   MessageType = 0
	MessageTypeNodeChanges                 MessageType = 1
	MessageTypeUserChanges                 MessageType = 2
	MessageTypeJoinEnd                     MessageType = 3
	MessageTypeSignal                      MessageType = 4
	MessageTypeStyle                       MessageType = 5
	MessageTypeStyleSet                    MessageType = 6
	MessageTypeJoinStartSkipReload         MessageType = 7
	MessageTypeNotifyShouldUpgrade         MessageType = 8
	MessageTypeUpgradeDone                 MessageType = 9
	MessageTypeUpgradeRefresh              MessageType = 10
	MessageTypeSceneGraphQuery             MessageType = 11
	MessageTypeSceneGraphReply             MessageType = 12
	MessageTypeDiff                        MessageType = 13
	MessageTypeClientBroadcast             MessageType = 14
	MessageTypeJoinStartJournaled          MessageType = 15
	MessageTypeStreamStart                 MessageType = 16
	MessageTypeStreamEnd                   MessageType = 17
	MessageTypeInteractiveSlideChange      MessageType = 18
	MessageTypeReconnectSceneGraphQuery    MessageType = 19
	MessageTypeReconnectSceneGraphReply    MessageType = 20
	MessageTypeJoinEndIncrementalReconnect MessageType = 21
	MessageTypeNodeStatusChange            MessageType = 22
)

type Axis int

const (
	AxisX Axis = 0
	AxisY Axis = 1
)

type Access int

const (
	AccessReadOnly  Access = 0
	AccessReadWrite Access = 1
)

type NodePhase int

const (
	NodePhaseCreated NodePhase = 0
	NodePhaseRemoved NodePhase = 1
)

type WindingRule int

const (
	WindingRuleNonzero WindingRule = 0
	WindingRuleOdd     WindingRule = 1
)

type NodeType int

const (
	NodeTypeNone                    NodeType = 0
	NodeTypeDocument                NodeType = 1
	NodeTypeCanvas                  NodeType = 2
	NodeTypeGroup                   NodeType = 3
	NodeTypeFrame                   NodeType = 4
	NodeTypeBooleanOperation        NodeType = 5
	NodeTypeVector                  NodeType = 6
	NodeTypeStar                    NodeType = 7
	NodeTypeLine                    NodeType = 8
	NodeTypeEllipse                 NodeType = 9
	NodeTypeRectangle               NodeType = 10
	NodeTypeRegularPolygon          NodeType = 11
	NodeTypeRoundedRectangle        NodeType = 12
	NodeTypeText                    NodeType = 13
	NodeTypeSlice                   NodeType = 14
	NodeTypeSymbol                  NodeType = 15
	NodeTypeInstance                NodeType = 16
	NodeTypeSticky                  NodeType = 17
	NodeTypeShapeWithText           NodeType = 18
	NodeTypeConnector               NodeType = 19
	NodeTypeCodeBlock               NodeType = 20
	NodeTypeWidget                  NodeType = 21
	NodeTypeStamp                   NodeType = 22
	NodeTypeMedia                   NodeType = 23
	NodeTypeHighlight               NodeType = 24
	NodeTypeSection                 NodeType = 25
	NodeTypeSectionOverlay          NodeType = 26
	NodeTypeWashiTape               NodeType = 27
	NodeTypeVariable                NodeType = 28
	NodeTypeTable                   NodeType = 29
	NodeTypeTableCell               NodeType = 30
	NodeTypeVariableSet             NodeType = 31
	NodeTypeSlide                   NodeType = 32
	NodeTypeAssistedLayout          NodeType = 33
	NodeTypeInteractiveSlideElement NodeType = 34
	NodeTypeVariableOverride        NodeType = 35
	NodeTypeModule                  NodeType = 36
	NodeTypeSlideGrid               NodeType = 37
	NodeTypeSlideRow                NodeType = 38
	NodeTypeResponsiveSet           NodeType = 39
)

type ShapeWithTextType int

const (
	ShapeWithTextTypeSquare             ShapeWithTextType = 0
	ShapeWithTextTypeEllipse            ShapeWithTextType = 1
	ShapeWithTextTypeDiamond            ShapeWithTextType = 2
	ShapeWithTextTypeTriangleUp         ShapeWithTextType = 3
	ShapeWithTextTypeTriangleDown       ShapeWithTextType = 4
	ShapeWithTextTypeRoundedRectangle   ShapeWithTextType = 5
	ShapeWithTextTypeParallelogramRight ShapeWithTextType = 6
	ShapeWithTextTypeParallelogramLeft  ShapeWithTextType = 7
	ShapeWithTextTypeEngDatabase        ShapeWithTextType = 8
	ShapeWithTextTypeEngQueue           ShapeWithTextType = 9
	ShapeWithTextTypeEngFile            ShapeWithTextType = 10
	ShapeWithTextTypeEngFolder          ShapeWithTextType = 11
	ShapeWithTextTypeTrapezoid          ShapeWithTextType = 12
	ShapeWithTextTypePredefinedProcess  ShapeWithTextType = 13
	ShapeWithTextTypeShield             ShapeWithTextType = 14
	ShapeWithTextTypeDocumentSingle     ShapeWithTextType = 15
	ShapeWithTextTypeDocumentMultiple   ShapeWithTextType = 16
	ShapeWithTextTypeManualInput        ShapeWithTextType = 17
	ShapeWithTextTypeHexagon            ShapeWithTextType = 18
	ShapeWithTextTypeChevron            ShapeWithTextType = 19
	ShapeWithTextTypePentagon           ShapeWithTextType = 20
	ShapeWithTextTypeOctagon            ShapeWithTextType = 21
	ShapeWithTextTypeStar               ShapeWithTextType = 22
	ShapeWithTextTypePlus               ShapeWithTextType = 23
	ShapeWithTextTypeArrowLeft          ShapeWithTextType = 24
	ShapeWithTextTypeArrowRight         ShapeWithTextType = 25
	ShapeWithTextTypeSummingJunction    ShapeWithTextType = 26
	ShapeWithTextTypeOr                 ShapeWithTextType = 27
	ShapeWithTextTypeSpeechBubble       ShapeWithTextType = 28
	ShapeWithTextTypeInternalStorage    ShapeWithTextType = 29
)

type BlendMode int

const (
	BlendModePassThrough BlendMode = 0
	BlendModeNormal      BlendMode = 1
	BlendModeDarken      BlendMode = 2
	BlendModeMultiply    BlendMode = 3
	BlendModeLinearBurn  BlendMode = 4
	BlendModeColorBurn   BlendMode = 5
	BlendModeLighten     BlendMode = 6
	BlendModeScreen      BlendMode = 7
	BlendModeLinearDodge BlendMode = 8
	BlendModeColorDodge  BlendMode = 9
	BlendModeOverlay     BlendMode = 10
	BlendModeSoftLight   BlendMode = 11
	BlendModeHardLight   BlendMode = 12
	BlendModeDifference  BlendMode = 13
	BlendModeExclusion   BlendMode = 14
	BlendModeHue         BlendMode = 15
	BlendModeSaturation  BlendMode = 16
	BlendModeColor       BlendMode = 17
	BlendModeLuminosity  BlendMode = 18
)

type PaintType int

const (
	PaintTypeSolid           PaintType = 0
	PaintTypeGradientLinear  PaintType = 1
	PaintTypeGradientRadial  PaintType = 2
	PaintTypeGradientAngular PaintType = 3
	PaintTypeGradientDiamond PaintType = 4
	PaintTypeImage           PaintType = 5
	PaintTypeEmoji           PaintType = 6
	PaintTypeVideo           PaintType = 7
)

type ImageScaleMode int

const (
	ImageScaleModeStretch ImageScaleMode = 0
	ImageScaleModeFit     ImageScaleMode = 1
	ImageScaleModeFill    ImageScaleMode = 2
	ImageScaleModeTile    ImageScaleMode = 3
)

type EffectType int

const (
	EffectTypeInnerShadow    EffectType = 0
	EffectTypeDropShadow     EffectType = 1
	EffectTypeForegroundBlur EffectType = 2
	EffectTypeBackgroundBlur EffectType = 3
)

type TextCase int

const (
	TextCaseOriginal        TextCase = 0
	TextCaseUpper           TextCase = 1
	TextCaseLower           TextCase = 2
	TextCaseTitle           TextCase = 3
	TextCaseSmallCaps       TextCase = 4
	TextCaseSmallCapsForced TextCase = 5
)

type TextDecoration int

const (
	TextDecorationNone          TextDecoration = 0
	TextDecorationUnderline     TextDecoration = 1
	TextDecorationStrikethrough TextDecoration = 2
)

type LeadingTrim int

const (
	LeadingTrimNone      LeadingTrim = 0
	LeadingTrimCapHeight LeadingTrim = 1
)

type NumberUnits int

const (
	NumberUnitsRaw     NumberUnits = 0
	NumberUnitsPixels  NumberUnits = 1
	NumberUnitsPercent NumberUnits = 2
)

type ConstraintType int

const (
	ConstraintTypeMin      ConstraintType = 0
	ConstraintTypeCenter   ConstraintType = 1
	ConstraintTypeMax      ConstraintType = 2
	ConstraintTypeStretch  ConstraintType = 3
	ConstraintTypeScale    ConstraintType = 4
	ConstraintTypeFixedMin ConstraintType = 5
	ConstraintTypeFixedMax ConstraintType = 6
)

type StrokeAlign int

const (
	StrokeAlignCenter  StrokeAlign = 0
	StrokeAlignInside  StrokeAlign = 1
	StrokeAlignOutside StrokeAlign = 2
)

type StrokeCap int

const (
	StrokeCapNone             StrokeCap = 0
	StrokeCapRound            StrokeCap = 1
	StrokeCapSquare           StrokeCap = 2
	StrokeCapArrowLines       StrokeCap = 3
	StrokeCapArrowEquilateral StrokeCap = 4
	StrokeCapDiamondFilled    StrokeCap = 5
	StrokeCapTriangleFilled   StrokeCap = 6
	StrokeCapHighlight        StrokeCap = 7
	StrokeCapWashiTape1       StrokeCap = 8
	StrokeCapWashiTape2       StrokeCap = 9
	StrokeCapWashiTape3       StrokeCap = 10
	StrokeCapWashiTape4       StrokeCap = 11
	StrokeCapWashiTape5       StrokeCap = 12
	StrokeCapWashiTape6       StrokeCap = 13
	StrokeCapCircleFilled     StrokeCap = 14
)

type StrokeJoin int

const (
	StrokeJoinMiter StrokeJoin = 0
	StrokeJoinBevel StrokeJoin = 1
	StrokeJoinRound StrokeJoin = 2
)

type BooleanOperation int

const (
	BooleanOperationUnion     BooleanOperation = 0
	BooleanOperationIntersect BooleanOperation = 1
	BooleanOperationSubtract  BooleanOperation = 2
	BooleanOperationXor       BooleanOperation = 3
)

type TextAlignHorizontal int

const (
	TextAlignHorizontalLeft      TextAlignHorizontal = 0
	TextAlignHorizontalCenter    TextAlignHorizontal = 1
	TextAlignHorizontalRight     TextAlignHorizontal = 2
	TextAlignHorizontalJustified TextAlignHorizontal = 3
)

type TextAlignVertical int

const (
	TextAlignVerticalTop    TextAlignVertical = 0
	TextAlignVerticalCenter TextAlignVertical = 1
	TextAlignVerticalBottom TextAlignVertical = 2
)

type MouseCursor int

const (
	MouseCursorDefault     MouseCursor = 0
	MouseCursorCrosshair   MouseCursor = 1
	MouseCursorEyedropper  MouseCursor = 2
	MouseCursorHand        MouseCursor = 3
	MouseCursorPaintBucket MouseCursor = 4
	MouseCursorPen         MouseCursor = 5
	MouseCursorPencil      MouseCursor = 6
	MouseCursorMarker      MouseCursor = 7
	MouseCursorEraser      MouseCursor = 8
	MouseCursorHighlighter MouseCursor = 9
	MouseCursorLasso       MouseCursor = 10
)

type VectorMirror int

const (
	VectorMirrorNone           VectorMirror = 0
	VectorMirrorAngle          VectorMirror = 1
	VectorMirrorAngleAndLength VectorMirror = 2
)

type DashMode int

const (
	DashModeClip    DashMode = 0
	DashModeStretch DashMode = 1
)

type ImageType int

const (
	ImageTypePng  ImageType = 0
	ImageTypeJpeg ImageType = 1
	ImageTypeSvg  ImageType = 2
	ImageTypePdf  ImageType = 3
)

type ExportConstraintType int

const (
	ExportConstraintTypeContentScale  ExportConstraintType = 0
	ExportConstraintTypeContentWidth  ExportConstraintType = 1
	ExportConstraintTypeContentHeight ExportConstraintType = 2
)

type LayoutGridType int

const (
	LayoutGridTypeMin     LayoutGridType = 0
	LayoutGridTypeCenter  LayoutGridType = 1
	LayoutGridTypeStretch LayoutGridType = 2
	LayoutGridTypeMax     LayoutGridType = 3
)

type LayoutGridPattern int

const (
	LayoutGridPatternStripes LayoutGridPattern = 0
	LayoutGridPatternGrid    LayoutGridPattern = 1
)

type TextAutoResize int

const (
	TextAutoResizeNone           TextAutoResize = 0
	TextAutoResizeWidthAndHeight TextAutoResize = 1
	TextAutoResizeHeight         TextAutoResize = 2
)

type TextTruncation int

const (
	TextTruncationDisabled TextTruncation = 0
	TextTruncationEnding   TextTruncation = 1
)

type StyleSetType int

const (
	StyleSetTypePersonal  StyleSetType = 0
	StyleSetTypeTeam      StyleSetType = 1
	StyleSetTypeCustom    StyleSetType = 2
	StyleSetTypeFrequency StyleSetType = 3
	StyleSetTypeTemporary StyleSetType = 4
)

type StyleSetContentType int

const (
	StyleSetContentTypeSolid    StyleSetContentType = 0
	StyleSetContentTypeGradient StyleSetContentType = 1
	StyleSetContentTypeImage    StyleSetContentType = 2
)

type StackMode int

const (
	StackModeNone       StackMode = 0
	StackModeHorizontal StackMode = 1
	StackModeVertical   StackMode = 2
)

type StackAlign int

const (
	StackAlignMin      StackAlign = 0
	StackAlignCenter   StackAlign = 1
	StackAlignMax      StackAlign = 2
	StackAlignBaseline StackAlign = 3
)

type StackCounterAlign int

const (
	StackCounterAlignMin      StackCounterAlign = 0
	StackCounterAlignCenter   StackCounterAlign = 1
	StackCounterAlignMax      StackCounterAlign = 2
	StackCounterAlignStretch  StackCounterAlign = 3
	StackCounterAlignAuto     StackCounterAlign = 4
	StackCounterAlignBaseline StackCounterAlign = 5
)

type StackJustify int

const (
	StackJustifyMin          StackJustify = 0
	StackJustifyCenter       StackJustify = 1
	StackJustifyMax          StackJustify = 2
	StackJustifySpaceEvenly  StackJustify = 3
	StackJustifySpaceBetween StackJustify = 4
)

type StackSize int

const (
	StackSizeFixed                       StackSize = 0
	StackSizeResizeToFit                 StackSize = 1
	StackSizeResizeToFitWithImplicitSize StackSize = 2
)

type StackPositioning int

const (
	StackPositioningAuto     StackPositioning = 0
	StackPositioningAbsolute StackPositioning = 1
)

type StackWrap int

const (
	StackWrapNoWrap StackWrap = 0
	StackWrapWrap   StackWrap = 1
)

type StackCounterAlignContent int

const (
	StackCounterAlignContentAuto         StackCounterAlignContent = 0
	StackCounterAlignContentSpaceBetween StackCounterAlignContent = 1
)

type ConnectionType int

const (
	ConnectionTypeNone               ConnectionType = 0
	ConnectionTypeInternalNode       ConnectionType = 1
	ConnectionTypeUrl                ConnectionType = 2
	ConnectionTypeBack               ConnectionType = 3
	ConnectionTypeClose              ConnectionType = 4
	ConnectionTypeSetVariable        ConnectionType = 5
	ConnectionTypeUpdateMediaRuntime ConnectionType = 6
	ConnectionTypeConditional        ConnectionType = 7
	ConnectionTypeSetVariableMode    ConnectionType = 8
)

type InteractionType int

const (
	InteractionTypeOnClick      InteractionType = 0
	InteractionTypeAfterTimeout InteractionType = 1
	InteractionTypeMouseIn      InteractionType = 2
	InteractionTypeMouseOut     InteractionType = 3
	InteractionTypeOnHover      InteractionType = 4
	InteractionTypeMouseDown    InteractionType = 5
	InteractionTypeMouseUp      InteractionType = 6
	InteractionTypeOnPress      InteractionType = 7
	InteractionTypeNone         InteractionType = 8
	InteractionTypeDrag         InteractionType = 9
	InteractionTypeOnKeyDown    InteractionType = 10
	InteractionTypeOnVoice      InteractionType = 11
	InteractionTypeOnMediaHit   InteractionType = 12
	InteractionTypeOnMediaEnd   InteractionType = 13
	InteractionTypeMouseEnter   InteractionType = 14
	InteractionTypeMouseLeave   InteractionType = 15
)

type TransitionType int

const (
	TransitionTypeInstantTransition TransitionType = 0
	TransitionTypeDissolve          TransitionType = 1
	TransitionTypeFade              TransitionType = 2
	TransitionTypeSlideFromLeft     TransitionType = 3
	TransitionTypeSlideFromRight    TransitionType = 4
	TransitionTypeSlideFromTop      TransitionType = 5
	TransitionTypeSlideFromBottom   TransitionType = 6
	TransitionTypePushFromLeft      TransitionType = 7
	TransitionTypePushFromRight     TransitionType = 8
	TransitionTypePushFromTop       TransitionType = 9
	TransitionTypePushFromBottom    TransitionType = 10
	TransitionTypeMoveFromLeft      TransitionType = 11
	TransitionTypeMoveFromRight     TransitionType = 12
	TransitionTypeMoveFromTop       TransitionType = 13
	TransitionTypeMoveFromBottom    TransitionType = 14
	TransitionTypeSlideOutToLeft    TransitionType = 15
	TransitionTypeSlideOutToRight   TransitionType = 16
	TransitionTypeSlideOutToTop     TransitionType = 17
	TransitionTypeSlideOutToBottom  TransitionType = 18
	TransitionTypeMoveOutToLeft     TransitionType = 19
	TransitionTypeMoveOutToRight    TransitionType = 20
	TransitionTypeMoveOutToTop      TransitionType = 21
	TransitionTypeMoveOutToBottom   TransitionType = 22
	TransitionTypeMagicMove         TransitionType = 23
	TransitionTypeSmartAnimate      TransitionType = 24
	TransitionTypeScrollAnimate     TransitionType = 25
)

type EasingType int

const (
	EasingTypeInCubic           EasingType = 0
	EasingTypeOutCubic          EasingType = 1
	EasingTypeInoutCubic        EasingType = 2
	EasingTypeLinear            EasingType = 3
	EasingTypeInBackCubic       EasingType = 4
	EasingTypeOutBackCubic      EasingType = 5
	EasingTypeInoutBackCubic    EasingType = 6
	EasingTypeCustomCubic       EasingType = 7
	EasingTypeSpring            EasingType = 8
	EasingTypeGentleSpring      EasingType = 9
	EasingTypeCustomSpring      EasingType = 10
	EasingTypeSpringPresetOne   EasingType = 11
	EasingTypeSpringPresetTwo   EasingType = 12
	EasingTypeSpringPresetThree EasingType = 13
)

type ScrollDirection int

const (
	ScrollDirectionNone       ScrollDirection = 0
	ScrollDirectionHorizontal ScrollDirection = 1
	ScrollDirectionVertical   ScrollDirection = 2
	ScrollDirectionBoth       ScrollDirection = 3
)

type ScrollContractedState int

const (
	ScrollContractedStateExpanded   ScrollContractedState = 0
	ScrollContractedStateContracted ScrollContractedState = 1
)

type GUID struct {
	SessionId uint
	LocalId   uint
}

func DecodeGUID(b *gokiwi.Buffer) (res *GUID, err error) {
	res = &GUID{}
	res.SessionId, err = b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	res.LocalId, err = b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	return
}

type Color struct {
	R float64
	G float64
	B float64
	A float64
}

func DecodeColor(b *gokiwi.Buffer) (res *Color, err error) {
	res = &Color{}
	res.R, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.G, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.B, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.A, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type Vector struct {
	X float64
	Y float64
}

func DecodeVector(b *gokiwi.Buffer) (res *Vector, err error) {
	res = &Vector{}
	res.X, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Y, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type Rect struct {
	X float64
	Y float64
	W float64
	H float64
}

func DecodeRect(b *gokiwi.Buffer) (res *Rect, err error) {
	res = &Rect{}
	res.X, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Y, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.W, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.H, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type ColorStop struct {
	Color    *Color
	Position float64
}

func DecodeColorStop(b *gokiwi.Buffer) (res *ColorStop, err error) {
	res = &ColorStop{}
	res.Color, err = DecodeColor(b)
	if err != nil {
		return nil, err
	}
	res.Position, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type ColorStopVar struct {
	Color    *Color        `kiwi_index:"1"`
	ColorVar *VariableData `kiwi_index:"2"`
	Position float64       `kiwi_index:"3"`
}

func DecodeColorStopVar(b *gokiwi.Buffer) (res *ColorStopVar, err error) {
	res = &ColorStopVar{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Color, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.ColorVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.Position, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Matrix struct {
	M00 float64
	M01 float64
	M02 float64
	M10 float64
	M11 float64
	M12 float64
}

func DecodeMatrix(b *gokiwi.Buffer) (res *Matrix, err error) {
	res = &Matrix{}
	res.M00, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.M01, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.M02, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.M10, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.M11, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.M12, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type ParentIndex struct {
	Guid     *GUID
	Position string
}

func DecodeParentIndex(b *gokiwi.Buffer) (res *ParentIndex, err error) {
	res = &ParentIndex{}
	res.Guid, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.Position, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	return
}

type Number struct {
	Value float64
	Units NumberUnits
}

func DecodeNumber(b *gokiwi.Buffer) (res *Number, err error) {
	res = &Number{}
	res.Value, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	v, err := b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	res.Units = NumberUnits(v)
	return
}

type FontName struct {
	Family     string
	Style      string
	Postscript string
}

func DecodeFontName(b *gokiwi.Buffer) (res *FontName, err error) {
	res = &FontName{}
	res.Family, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.Style, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.Postscript, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	return
}

type FontVariantNumericFigure int

const (
	FontVariantNumericFigureNormal   FontVariantNumericFigure = 0
	FontVariantNumericFigureLining   FontVariantNumericFigure = 1
	FontVariantNumericFigureOldstyle FontVariantNumericFigure = 2
)

type FontVariantNumericSpacing int

const (
	FontVariantNumericSpacingNormal       FontVariantNumericSpacing = 0
	FontVariantNumericSpacingProportional FontVariantNumericSpacing = 1
	FontVariantNumericSpacingTabular      FontVariantNumericSpacing = 2
)

type FontVariantNumericFraction int

const (
	FontVariantNumericFractionNormal   FontVariantNumericFraction = 0
	FontVariantNumericFractionDiagonal FontVariantNumericFraction = 1
	FontVariantNumericFractionStacked  FontVariantNumericFraction = 2
)

type FontVariantCaps int

const (
	FontVariantCapsNormal    FontVariantCaps = 0
	FontVariantCapsSmall     FontVariantCaps = 1
	FontVariantCapsAllSmall  FontVariantCaps = 2
	FontVariantCapsPetite    FontVariantCaps = 3
	FontVariantCapsAllPetite FontVariantCaps = 4
	FontVariantCapsUnicase   FontVariantCaps = 5
	FontVariantCapsTitling   FontVariantCaps = 6
)

type FontVariantPosition int

const (
	FontVariantPositionNormal FontVariantPosition = 0
	FontVariantPositionSub    FontVariantPosition = 1
	FontVariantPositionSuper  FontVariantPosition = 2
)

type FontStyle int

const (
	FontStyleNormal FontStyle = 0
	FontStyleItalic FontStyle = 1
)

type SemanticWeight int

const (
	SemanticWeightNormal SemanticWeight = 0
	SemanticWeightBold   SemanticWeight = 1
)

type SemanticItalic int

const (
	SemanticItalicNormal SemanticItalic = 0
	SemanticItalicItalic SemanticItalic = 1
)

type OpenTypeFeature int

const (
	OpenTypeFeaturePcap OpenTypeFeature = 0
	OpenTypeFeatureC2pc OpenTypeFeature = 1
	OpenTypeFeatureCase OpenTypeFeature = 2
	OpenTypeFeatureCpsp OpenTypeFeature = 3
	OpenTypeFeatureTitl OpenTypeFeature = 4
	OpenTypeFeatureUnic OpenTypeFeature = 5
	OpenTypeFeatureZero OpenTypeFeature = 6
	OpenTypeFeatureSinf OpenTypeFeature = 7
	OpenTypeFeatureOrdn OpenTypeFeature = 8
	OpenTypeFeatureAfrc OpenTypeFeature = 9
	OpenTypeFeatureDnom OpenTypeFeature = 10
	OpenTypeFeatureNumr OpenTypeFeature = 11
	OpenTypeFeatureLiga OpenTypeFeature = 12
	OpenTypeFeatureClig OpenTypeFeature = 13
	OpenTypeFeatureDlig OpenTypeFeature = 14
	OpenTypeFeatureHlig OpenTypeFeature = 15
	OpenTypeFeatureRlig OpenTypeFeature = 16
	OpenTypeFeatureAalt OpenTypeFeature = 17
	OpenTypeFeatureCalt OpenTypeFeature = 18
	OpenTypeFeatureRclt OpenTypeFeature = 19
	OpenTypeFeatureSalt OpenTypeFeature = 20
	OpenTypeFeatureRvrn OpenTypeFeature = 21
	OpenTypeFeatureVert OpenTypeFeature = 22
	OpenTypeFeatureSwsh OpenTypeFeature = 23
	OpenTypeFeatureCswh OpenTypeFeature = 24
	OpenTypeFeatureNalt OpenTypeFeature = 25
	OpenTypeFeatureCcmp OpenTypeFeature = 26
	OpenTypeFeatureStch OpenTypeFeature = 27
	OpenTypeFeatureHist OpenTypeFeature = 28
	OpenTypeFeatureSize OpenTypeFeature = 29
	OpenTypeFeatureOrnm OpenTypeFeature = 30
	OpenTypeFeatureItal OpenTypeFeature = 31
	OpenTypeFeatureRand OpenTypeFeature = 32
	OpenTypeFeatureDtls OpenTypeFeature = 33
	OpenTypeFeatureFlac OpenTypeFeature = 34
	OpenTypeFeatureMgrk OpenTypeFeature = 35
	OpenTypeFeatureSsty OpenTypeFeature = 36
	OpenTypeFeatureKern OpenTypeFeature = 37
	OpenTypeFeatureFwid OpenTypeFeature = 38
	OpenTypeFeatureHwid OpenTypeFeature = 39
	OpenTypeFeatureHalt OpenTypeFeature = 40
	OpenTypeFeatureTwid OpenTypeFeature = 41
	OpenTypeFeatureQwid OpenTypeFeature = 42
	OpenTypeFeaturePwid OpenTypeFeature = 43
	OpenTypeFeatureJust OpenTypeFeature = 44
	OpenTypeFeatureLfbd OpenTypeFeature = 45
	OpenTypeFeatureOpbd OpenTypeFeature = 46
	OpenTypeFeatureRtbd OpenTypeFeature = 47
	OpenTypeFeaturePalt OpenTypeFeature = 48
	OpenTypeFeaturePkna OpenTypeFeature = 49
	OpenTypeFeatureLtra OpenTypeFeature = 50
	OpenTypeFeatureLtrm OpenTypeFeature = 51
	OpenTypeFeatureRtla OpenTypeFeature = 52
	OpenTypeFeatureRtlm OpenTypeFeature = 53
	OpenTypeFeatureAbrv OpenTypeFeature = 54
	OpenTypeFeatureAbvm OpenTypeFeature = 55
	OpenTypeFeatureAbvs OpenTypeFeature = 56
	OpenTypeFeatureValt OpenTypeFeature = 57
	OpenTypeFeatureVhal OpenTypeFeature = 58
	OpenTypeFeatureBlwf OpenTypeFeature = 59
	OpenTypeFeatureBlwm OpenTypeFeature = 60
	OpenTypeFeatureBlws OpenTypeFeature = 61
	OpenTypeFeatureAkhn OpenTypeFeature = 62
	OpenTypeFeatureCjct OpenTypeFeature = 63
	OpenTypeFeatureCfar OpenTypeFeature = 64
	OpenTypeFeatureCpct OpenTypeFeature = 65
	OpenTypeFeatureCurs OpenTypeFeature = 66
	OpenTypeFeatureDist OpenTypeFeature = 67
	OpenTypeFeatureExpt OpenTypeFeature = 68
	OpenTypeFeatureFalt OpenTypeFeature = 69
	OpenTypeFeatureFina OpenTypeFeature = 70
	OpenTypeFeatureFin2 OpenTypeFeature = 71
	OpenTypeFeatureFin3 OpenTypeFeature = 72
	OpenTypeFeatureHalf OpenTypeFeature = 73
	OpenTypeFeatureHaln OpenTypeFeature = 74
	OpenTypeFeatureHkna OpenTypeFeature = 75
	OpenTypeFeatureHngl OpenTypeFeature = 76
	OpenTypeFeatureHojo OpenTypeFeature = 77
	OpenTypeFeatureInit OpenTypeFeature = 78
	OpenTypeFeatureIsol OpenTypeFeature = 79
	OpenTypeFeatureJp78 OpenTypeFeature = 80
	OpenTypeFeatureJp83 OpenTypeFeature = 81
	OpenTypeFeatureJp90 OpenTypeFeature = 82
	OpenTypeFeatureJp04 OpenTypeFeature = 83
	OpenTypeFeatureLjmo OpenTypeFeature = 84
	OpenTypeFeatureLocl OpenTypeFeature = 85
	OpenTypeFeatureMark OpenTypeFeature = 86
	OpenTypeFeatureMedi OpenTypeFeature = 87
	OpenTypeFeatureMed2 OpenTypeFeature = 88
	OpenTypeFeatureMkmk OpenTypeFeature = 89
	OpenTypeFeatureNlck OpenTypeFeature = 90
	OpenTypeFeatureNukt OpenTypeFeature = 91
	OpenTypeFeaturePref OpenTypeFeature = 92
	OpenTypeFeaturePres OpenTypeFeature = 93
	OpenTypeFeatureVpal OpenTypeFeature = 94
	OpenTypeFeaturePstf OpenTypeFeature = 95
	OpenTypeFeaturePsts OpenTypeFeature = 96
	OpenTypeFeatureRkrf OpenTypeFeature = 97
	OpenTypeFeatureRphf OpenTypeFeature = 98
	OpenTypeFeatureRuby OpenTypeFeature = 99
	OpenTypeFeatureSmpl OpenTypeFeature = 100
	OpenTypeFeatureTjmo OpenTypeFeature = 101
	OpenTypeFeatureTnam OpenTypeFeature = 102
	OpenTypeFeatureTrad OpenTypeFeature = 103
	OpenTypeFeatureVatu OpenTypeFeature = 104
	OpenTypeFeatureVjmo OpenTypeFeature = 105
	OpenTypeFeatureVkna OpenTypeFeature = 106
	OpenTypeFeatureVkrn OpenTypeFeature = 107
	OpenTypeFeatureVrtr OpenTypeFeature = 108
	OpenTypeFeatureVrt2 OpenTypeFeature = 109
	OpenTypeFeatureSs01 OpenTypeFeature = 110
	OpenTypeFeatureSs02 OpenTypeFeature = 111
	OpenTypeFeatureSs03 OpenTypeFeature = 112
	OpenTypeFeatureSs04 OpenTypeFeature = 113
	OpenTypeFeatureSs05 OpenTypeFeature = 114
	OpenTypeFeatureSs06 OpenTypeFeature = 115
	OpenTypeFeatureSs07 OpenTypeFeature = 116
	OpenTypeFeatureSs08 OpenTypeFeature = 117
	OpenTypeFeatureSs09 OpenTypeFeature = 118
	OpenTypeFeatureSs10 OpenTypeFeature = 119
	OpenTypeFeatureSs11 OpenTypeFeature = 120
	OpenTypeFeatureSs12 OpenTypeFeature = 121
	OpenTypeFeatureSs13 OpenTypeFeature = 122
	OpenTypeFeatureSs14 OpenTypeFeature = 123
	OpenTypeFeatureSs15 OpenTypeFeature = 124
	OpenTypeFeatureSs16 OpenTypeFeature = 125
	OpenTypeFeatureSs17 OpenTypeFeature = 126
	OpenTypeFeatureSs18 OpenTypeFeature = 127
	OpenTypeFeatureSs19 OpenTypeFeature = 128
	OpenTypeFeatureSs20 OpenTypeFeature = 129
	OpenTypeFeatureCv01 OpenTypeFeature = 130
	OpenTypeFeatureCv02 OpenTypeFeature = 131
	OpenTypeFeatureCv03 OpenTypeFeature = 132
	OpenTypeFeatureCv04 OpenTypeFeature = 133
	OpenTypeFeatureCv05 OpenTypeFeature = 134
	OpenTypeFeatureCv06 OpenTypeFeature = 135
	OpenTypeFeatureCv07 OpenTypeFeature = 136
	OpenTypeFeatureCv08 OpenTypeFeature = 137
	OpenTypeFeatureCv09 OpenTypeFeature = 138
	OpenTypeFeatureCv10 OpenTypeFeature = 139
	OpenTypeFeatureCv11 OpenTypeFeature = 140
	OpenTypeFeatureCv12 OpenTypeFeature = 141
	OpenTypeFeatureCv13 OpenTypeFeature = 142
	OpenTypeFeatureCv14 OpenTypeFeature = 143
	OpenTypeFeatureCv15 OpenTypeFeature = 144
	OpenTypeFeatureCv16 OpenTypeFeature = 145
	OpenTypeFeatureCv17 OpenTypeFeature = 146
	OpenTypeFeatureCv18 OpenTypeFeature = 147
	OpenTypeFeatureCv19 OpenTypeFeature = 148
	OpenTypeFeatureCv20 OpenTypeFeature = 149
	OpenTypeFeatureCv21 OpenTypeFeature = 150
	OpenTypeFeatureCv22 OpenTypeFeature = 151
	OpenTypeFeatureCv23 OpenTypeFeature = 152
	OpenTypeFeatureCv24 OpenTypeFeature = 153
	OpenTypeFeatureCv25 OpenTypeFeature = 154
	OpenTypeFeatureCv26 OpenTypeFeature = 155
	OpenTypeFeatureCv27 OpenTypeFeature = 156
	OpenTypeFeatureCv28 OpenTypeFeature = 157
	OpenTypeFeatureCv29 OpenTypeFeature = 158
	OpenTypeFeatureCv30 OpenTypeFeature = 159
	OpenTypeFeatureCv31 OpenTypeFeature = 160
	OpenTypeFeatureCv32 OpenTypeFeature = 161
	OpenTypeFeatureCv33 OpenTypeFeature = 162
	OpenTypeFeatureCv34 OpenTypeFeature = 163
	OpenTypeFeatureCv35 OpenTypeFeature = 164
	OpenTypeFeatureCv36 OpenTypeFeature = 165
	OpenTypeFeatureCv37 OpenTypeFeature = 166
	OpenTypeFeatureCv38 OpenTypeFeature = 167
	OpenTypeFeatureCv39 OpenTypeFeature = 168
	OpenTypeFeatureCv40 OpenTypeFeature = 169
	OpenTypeFeatureCv41 OpenTypeFeature = 170
	OpenTypeFeatureCv42 OpenTypeFeature = 171
	OpenTypeFeatureCv43 OpenTypeFeature = 172
	OpenTypeFeatureCv44 OpenTypeFeature = 173
	OpenTypeFeatureCv45 OpenTypeFeature = 174
	OpenTypeFeatureCv46 OpenTypeFeature = 175
	OpenTypeFeatureCv47 OpenTypeFeature = 176
	OpenTypeFeatureCv48 OpenTypeFeature = 177
	OpenTypeFeatureCv49 OpenTypeFeature = 178
	OpenTypeFeatureCv50 OpenTypeFeature = 179
	OpenTypeFeatureCv51 OpenTypeFeature = 180
	OpenTypeFeatureCv52 OpenTypeFeature = 181
	OpenTypeFeatureCv53 OpenTypeFeature = 182
	OpenTypeFeatureCv54 OpenTypeFeature = 183
	OpenTypeFeatureCv55 OpenTypeFeature = 184
	OpenTypeFeatureCv56 OpenTypeFeature = 185
	OpenTypeFeatureCv57 OpenTypeFeature = 186
	OpenTypeFeatureCv58 OpenTypeFeature = 187
	OpenTypeFeatureCv59 OpenTypeFeature = 188
	OpenTypeFeatureCv60 OpenTypeFeature = 189
	OpenTypeFeatureCv61 OpenTypeFeature = 190
	OpenTypeFeatureCv62 OpenTypeFeature = 191
	OpenTypeFeatureCv63 OpenTypeFeature = 192
	OpenTypeFeatureCv64 OpenTypeFeature = 193
	OpenTypeFeatureCv65 OpenTypeFeature = 194
	OpenTypeFeatureCv66 OpenTypeFeature = 195
	OpenTypeFeatureCv67 OpenTypeFeature = 196
	OpenTypeFeatureCv68 OpenTypeFeature = 197
	OpenTypeFeatureCv69 OpenTypeFeature = 198
	OpenTypeFeatureCv70 OpenTypeFeature = 199
	OpenTypeFeatureCv71 OpenTypeFeature = 200
	OpenTypeFeatureCv72 OpenTypeFeature = 201
	OpenTypeFeatureCv73 OpenTypeFeature = 202
	OpenTypeFeatureCv74 OpenTypeFeature = 203
	OpenTypeFeatureCv75 OpenTypeFeature = 204
	OpenTypeFeatureCv76 OpenTypeFeature = 205
	OpenTypeFeatureCv77 OpenTypeFeature = 206
	OpenTypeFeatureCv78 OpenTypeFeature = 207
	OpenTypeFeatureCv79 OpenTypeFeature = 208
	OpenTypeFeatureCv80 OpenTypeFeature = 209
	OpenTypeFeatureCv81 OpenTypeFeature = 210
	OpenTypeFeatureCv82 OpenTypeFeature = 211
	OpenTypeFeatureCv83 OpenTypeFeature = 212
	OpenTypeFeatureCv84 OpenTypeFeature = 213
	OpenTypeFeatureCv85 OpenTypeFeature = 214
	OpenTypeFeatureCv86 OpenTypeFeature = 215
	OpenTypeFeatureCv87 OpenTypeFeature = 216
	OpenTypeFeatureCv88 OpenTypeFeature = 217
	OpenTypeFeatureCv89 OpenTypeFeature = 218
	OpenTypeFeatureCv90 OpenTypeFeature = 219
	OpenTypeFeatureCv91 OpenTypeFeature = 220
	OpenTypeFeatureCv92 OpenTypeFeature = 221
	OpenTypeFeatureCv93 OpenTypeFeature = 222
	OpenTypeFeatureCv94 OpenTypeFeature = 223
	OpenTypeFeatureCv95 OpenTypeFeature = 224
	OpenTypeFeatureCv96 OpenTypeFeature = 225
	OpenTypeFeatureCv97 OpenTypeFeature = 226
	OpenTypeFeatureCv98 OpenTypeFeature = 227
	OpenTypeFeatureCv99 OpenTypeFeature = 228
)

type ExportConstraint struct {
	Type  ExportConstraintType
	Value float64
}

func DecodeExportConstraint(b *gokiwi.Buffer) (res *ExportConstraint, err error) {
	res = &ExportConstraint{}
	v, err := b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	res.Type = ExportConstraintType(v)
	res.Value, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type GUIDMapping struct {
	From *GUID
	To   *GUID
}

func DecodeGUIDMapping(b *gokiwi.Buffer) (res *GUIDMapping, err error) {
	res = &GUIDMapping{}
	res.From, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.To, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	return
}

type Blob struct {
	Bytes []byte
}

func DecodeBlob(b *gokiwi.Buffer) (res *Blob, err error) {
	res = &Blob{}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]byte, size)
		for i := range size {
			values[i], err = b.ReadByte()
			if err != nil {
				return nil, err
			}
		}
		res.Bytes = values
	}
	return
}

type Image struct {
	Hash     []byte `kiwi_index:"1"`
	Name     string `kiwi_index:"2"`
	DataBlob uint   `kiwi_index:"3"`
}

func DecodeImage(b *gokiwi.Buffer) (res *Image, err error) {
	res = &Image{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]byte, size)
				for i := range size {
					values[i], err = b.ReadByte()
					if err != nil {
						return nil, err
					}
				}
				res.Hash = values
			}
		case 2:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.DataBlob, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Video struct {
	Hash  []byte `kiwi_index:"1"`
	S3url string `kiwi_index:"2"`
}

func DecodeVideo(b *gokiwi.Buffer) (res *Video, err error) {
	res = &Video{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]byte, size)
				for i := range size {
					values[i], err = b.ReadByte()
					if err != nil {
						return nil, err
					}
				}
				res.Hash = values
			}
		case 2:
			res.S3url, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PasteSource struct {
	SrcFile string `kiwi_index:"1"`
	SrcNode *GUID  `kiwi_index:"2"`
}

func DecodePasteSource(b *gokiwi.Buffer) (res *PasteSource, err error) {
	res = &PasteSource{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SrcFile, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.SrcNode, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type FilterColorAdjust struct {
	Tint        float64
	Shadows     float64
	Highlights  float64
	Detail      float64
	Exposure    float64
	Vignette    float64
	Temperature float64
	Vibrance    float64
}

func DecodeFilterColorAdjust(b *gokiwi.Buffer) (res *FilterColorAdjust, err error) {
	res = &FilterColorAdjust{}
	res.Tint, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Shadows, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Highlights, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Detail, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Exposure, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Vignette, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Temperature, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Vibrance, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type PaintFilterMessage struct {
	Tint        float64 `kiwi_index:"1"`
	Shadows     float64 `kiwi_index:"2"`
	Highlights  float64 `kiwi_index:"3"`
	Detail      float64 `kiwi_index:"4"`
	Exposure    float64 `kiwi_index:"5"`
	Vignette    float64 `kiwi_index:"6"`
	Temperature float64 `kiwi_index:"7"`
	Vibrance    float64 `kiwi_index:"8"`
	Contrast    float64 `kiwi_index:"9"`
	Brightness  float64 `kiwi_index:"10"`
}

func DecodePaintFilterMessage(b *gokiwi.Buffer) (res *PaintFilterMessage, err error) {
	res = &PaintFilterMessage{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Tint, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Shadows, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Highlights, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.Detail, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 5:
			res.Exposure, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 6:
			res.Vignette, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.Temperature, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 8:
			res.Vibrance, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 9:
			res.Contrast, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 10:
			res.Brightness, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Paint struct {
	Type                   PaintType           `kiwi_index:"1"`
	Color                  *Color              `kiwi_index:"2"`
	Opacity                float64             `kiwi_index:"3"`
	Visible                bool                `kiwi_index:"4"`
	BlendMode              BlendMode           `kiwi_index:"5"`
	Stops                  []*ColorStop        `kiwi_index:"6"`
	Transform              *Matrix             `kiwi_index:"7"`
	Image                  *Image              `kiwi_index:"8"`
	ImageThumbnail         *Image              `kiwi_index:"9"`
	AnimatedImage          *Image              `kiwi_index:"16"`
	AnimationFrame         uint                `kiwi_index:"17"`
	ImageScaleMode         ImageScaleMode      `kiwi_index:"10"`
	ImageShouldColorManage bool                `kiwi_index:"22"`
	Rotation               float64             `kiwi_index:"11"`
	Scale                  float64             `kiwi_index:"12"`
	FilterColorAdjust      *FilterColorAdjust  `kiwi_index:"13"`
	PaintFilter            *PaintFilterMessage `kiwi_index:"14"`
	EmojiCodePoints        []uint              `kiwi_index:"15"`
	Video                  *Video              `kiwi_index:"18"`
	OriginalImageWidth     uint                `kiwi_index:"19"`
	OriginalImageHeight    uint                `kiwi_index:"20"`
	ColorVar               *VariableData       `kiwi_index:"21"`
	StopsVar               []*ColorStopVar     `kiwi_index:"23"`
}

func DecodePaint(b *gokiwi.Buffer) (res *Paint, err error) {
	res = &Paint{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = PaintType(v)
		case 2:
			res.Color, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.Opacity, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Visible = v != 0
		case 5:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.BlendMode = BlendMode(v)
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ColorStop, size)
				for i := range size {
					v, err := DecodeColorStop(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Stops = values
			}
		case 7:
			res.Transform, err = DecodeMatrix(b)
			if err != nil {
				return nil, err
			}
		case 8:
			res.Image, err = DecodeImage(b)
			if err != nil {
				return nil, err
			}
		case 9:
			res.ImageThumbnail, err = DecodeImage(b)
			if err != nil {
				return nil, err
			}
		case 16:
			res.AnimatedImage, err = DecodeImage(b)
			if err != nil {
				return nil, err
			}
		case 17:
			res.AnimationFrame, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 10:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ImageScaleMode = ImageScaleMode(v)
		case 22:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ImageShouldColorManage = v != 0
		case 11:
			res.Rotation, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 12:
			res.Scale, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 13:
			res.FilterColorAdjust, err = DecodeFilterColorAdjust(b)
			if err != nil {
				return nil, err
			}
		case 14:
			res.PaintFilter, err = DecodePaintFilterMessage(b)
			if err != nil {
				return nil, err
			}
		case 15:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.EmojiCodePoints = values
			}
		case 18:
			res.Video, err = DecodeVideo(b)
			if err != nil {
				return nil, err
			}
		case 19:
			res.OriginalImageWidth, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 20:
			res.OriginalImageHeight, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 21:
			res.ColorVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 23:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ColorStopVar, size)
				for i := range size {
					v, err := DecodeColorStopVar(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StopsVar = values
			}
		}
	}
	return
}

type FontMetaData struct {
	Key            *FontName `kiwi_index:"1"`
	FontLineHeight float64   `kiwi_index:"2"`
	FontDigest     []byte    `kiwi_index:"3"`
	FontStyle      FontStyle `kiwi_index:"4"`
	FontWeight     int       `kiwi_index:"5"`
}

func DecodeFontMetaData(b *gokiwi.Buffer) (res *FontMetaData, err error) {
	res = &FontMetaData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Key, err = DecodeFontName(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.FontLineHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]byte, size)
				for i := range size {
					values[i], err = b.ReadByte()
					if err != nil {
						return nil, err
					}
				}
				res.FontDigest = values
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FontStyle = FontStyle(v)
		case 5:
			res.FontWeight, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type FontVariation struct {
	AxisTag  uint    `kiwi_index:"1"`
	AxisName string  `kiwi_index:"2"`
	Value    float64 `kiwi_index:"3"`
}

func DecodeFontVariation(b *gokiwi.Buffer) (res *FontVariation, err error) {
	res = &FontVariation{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.AxisTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.AxisName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Value, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TextData struct {
	Characters                       string                 `kiwi_index:"1"`
	CharacterStyleIDs                []uint                 `kiwi_index:"2"`
	StyleOverrideTable               []*NodeChange          `kiwi_index:"3"`
	Lines                            []*TextLineData        `kiwi_index:"12"`
	LayoutVersion                    uint                   `kiwi_index:"8"`
	FallbackFonts                    []*FontName            `kiwi_index:"10"`
	MinContentHeight                 float64                `kiwi_index:"17"`
	LayoutSize                       *Vector                `kiwi_index:"4"`
	Baselines                        []*Baseline            `kiwi_index:"5"`
	Glyphs                           []*Glyph               `kiwi_index:"6"`
	Decorations                      []*Decoration          `kiwi_index:"7"`
	Blockquotes                      []*Blockquote          `kiwi_index:"16"`
	FontMetaData                     []*FontMetaData        `kiwi_index:"9"`
	HyperlinkBoxes                   []*HyperlinkBox        `kiwi_index:"11"`
	TruncationStartIndex             int                    `kiwi_index:"13"`
	TruncatedHeight                  float64                `kiwi_index:"14"`
	LogicalIndexToCharacterOffsetMap []float64              `kiwi_index:"15"`
	MentionBoxes                     []*MentionBox          `kiwi_index:"18"`
	DerivedLines                     []*DerivedTextLineData `kiwi_index:"19"`
}

func DecodeTextData(b *gokiwi.Buffer) (res *TextData, err error) {
	res = &TextData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Characters, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.CharacterStyleIDs = values
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StyleOverrideTable = values
			}
		case 12:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TextLineData, size)
				for i := range size {
					v, err := DecodeTextLineData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Lines = values
			}
		case 8:
			res.LayoutVersion, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 10:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*FontName, size)
				for i := range size {
					v, err := DecodeFontName(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FallbackFonts = values
			}
		case 17:
			res.MinContentHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.LayoutSize, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Baseline, size)
				for i := range size {
					v, err := DecodeBaseline(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Baselines = values
			}
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Glyph, size)
				for i := range size {
					v, err := DecodeGlyph(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Glyphs = values
			}
		case 7:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Decoration, size)
				for i := range size {
					v, err := DecodeDecoration(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Decorations = values
			}
		case 16:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Blockquote, size)
				for i := range size {
					v, err := DecodeBlockquote(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Blockquotes = values
			}
		case 9:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*FontMetaData, size)
				for i := range size {
					v, err := DecodeFontMetaData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FontMetaData = values
			}
		case 11:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*HyperlinkBox, size)
				for i := range size {
					v, err := DecodeHyperlinkBox(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.HyperlinkBoxes = values
			}
		case 13:
			res.TruncationStartIndex, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 14:
			res.TruncatedHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 15:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]float64, size)
				for i := range size {
					values[i], err = b.ReadVarFloat()
					if err != nil {
						return nil, err
					}
				}
				res.LogicalIndexToCharacterOffsetMap = values
			}
		case 18:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*MentionBox, size)
				for i := range size {
					v, err := DecodeMentionBox(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.MentionBoxes = values
			}
		case 19:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*DerivedTextLineData, size)
				for i := range size {
					v, err := DecodeDerivedTextLineData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DerivedLines = values
			}
		}
	}
	return
}

type DerivedTextData struct {
	LayoutSize                       *Vector                `kiwi_index:"1"`
	Baselines                        []*Baseline            `kiwi_index:"2"`
	Glyphs                           []*Glyph               `kiwi_index:"3"`
	Decorations                      []*Decoration          `kiwi_index:"4"`
	Blockquotes                      []*Blockquote          `kiwi_index:"5"`
	FontMetaData                     []*FontMetaData        `kiwi_index:"6"`
	HyperlinkBoxes                   []*HyperlinkBox        `kiwi_index:"7"`
	TruncationStartIndex             int                    `kiwi_index:"8"`
	TruncatedHeight                  float64                `kiwi_index:"9"`
	LogicalIndexToCharacterOffsetMap []float64              `kiwi_index:"10"`
	MentionBoxes                     []*MentionBox          `kiwi_index:"11"`
	DerivedLines                     []*DerivedTextLineData `kiwi_index:"12"`
}

func DecodeDerivedTextData(b *gokiwi.Buffer) (res *DerivedTextData, err error) {
	res = &DerivedTextData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.LayoutSize, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Baseline, size)
				for i := range size {
					v, err := DecodeBaseline(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Baselines = values
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Glyph, size)
				for i := range size {
					v, err := DecodeGlyph(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Glyphs = values
			}
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Decoration, size)
				for i := range size {
					v, err := DecodeDecoration(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Decorations = values
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Blockquote, size)
				for i := range size {
					v, err := DecodeBlockquote(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Blockquotes = values
			}
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*FontMetaData, size)
				for i := range size {
					v, err := DecodeFontMetaData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FontMetaData = values
			}
		case 7:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*HyperlinkBox, size)
				for i := range size {
					v, err := DecodeHyperlinkBox(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.HyperlinkBoxes = values
			}
		case 8:
			res.TruncationStartIndex, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 9:
			res.TruncatedHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 10:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]float64, size)
				for i := range size {
					values[i], err = b.ReadVarFloat()
					if err != nil {
						return nil, err
					}
				}
				res.LogicalIndexToCharacterOffsetMap = values
			}
		case 11:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*MentionBox, size)
				for i := range size {
					v, err := DecodeMentionBox(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.MentionBoxes = values
			}
		case 12:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*DerivedTextLineData, size)
				for i := range size {
					v, err := DecodeDerivedTextLineData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DerivedLines = values
			}
		}
	}
	return
}

type HyperlinkBox struct {
	Bounds      *Rect  `kiwi_index:"1"`
	Url         string `kiwi_index:"2"`
	Guid        *GUID  `kiwi_index:"3"`
	HyperlinkId int    `kiwi_index:"4"`
}

func DecodeHyperlinkBox(b *gokiwi.Buffer) (res *HyperlinkBox, err error) {
	res = &HyperlinkBox{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Bounds, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Url, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.HyperlinkId, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type MentionBox struct {
	Bounds     *Rect `kiwi_index:"1"`
	StartIndex uint  `kiwi_index:"2"`
	EndIndex   uint  `kiwi_index:"3"`
	IsValid    bool  `kiwi_index:"4"`
	MentionKey uint  `kiwi_index:"5"`
}

func DecodeMentionBox(b *gokiwi.Buffer) (res *MentionBox, err error) {
	res = &MentionBox{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Bounds, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.StartIndex, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.EndIndex, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsValid = v != 0
		case 5:
			res.MentionKey, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Baseline struct {
	Position          *Vector `kiwi_index:"1"`
	Width             float64 `kiwi_index:"2"`
	LineY             float64 `kiwi_index:"3"`
	LineHeight        float64 `kiwi_index:"4"`
	LineAscent        float64 `kiwi_index:"7"`
	IgnoreLeadingTrim float64 `kiwi_index:"8"`
	FirstCharacter    uint    `kiwi_index:"5"`
	EndCharacter      uint    `kiwi_index:"6"`
}

func DecodeBaseline(b *gokiwi.Buffer) (res *Baseline, err error) {
	res = &Baseline{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Position, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Width, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			res.LineY, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.LineHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.LineAscent, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 8:
			res.IgnoreLeadingTrim, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 5:
			res.FirstCharacter, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 6:
			res.EndCharacter, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Glyph struct {
	CommandsBlob    uint          `kiwi_index:"1"`
	Position        *Vector       `kiwi_index:"2"`
	StyleId         uint          `kiwi_index:"3"`
	FontSize        float64       `kiwi_index:"4"`
	FirstCharacter  uint          `kiwi_index:"5"`
	Advance         float64       `kiwi_index:"6"`
	EmojiCodePoints []uint        `kiwi_index:"7"`
	EmojiImageSet   EmojiImageSet `kiwi_index:"8"`
}

func DecodeGlyph(b *gokiwi.Buffer) (res *Glyph, err error) {
	res = &Glyph{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.CommandsBlob, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Position, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.StyleId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			res.FontSize, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 5:
			res.FirstCharacter, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 6:
			res.Advance, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.EmojiCodePoints = values
			}
		case 8:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.EmojiImageSet = EmojiImageSet(v)
		}
	}
	return
}

type Decoration struct {
	Rects   []*Rect `kiwi_index:"1"`
	StyleId uint    `kiwi_index:"2"`
}

func DecodeDecoration(b *gokiwi.Buffer) (res *Decoration, err error) {
	res = &Decoration{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Rect, size)
				for i := range size {
					v, err := DecodeRect(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Rects = values
			}
		case 2:
			res.StyleId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Blockquote struct {
	VerticalBar     *Rect `kiwi_index:"1"`
	QuoteMarkBounds *Rect `kiwi_index:"2"`
	StyleId         uint  `kiwi_index:"3"`
}

func DecodeBlockquote(b *gokiwi.Buffer) (res *Blockquote, err error) {
	res = &Blockquote{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.VerticalBar, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.QuoteMarkBounds, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.StyleId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VectorData struct {
	VectorNetworkBlob  uint          `kiwi_index:"1"`
	NormalizedSize     *Vector       `kiwi_index:"2"`
	StyleOverrideTable []*NodeChange `kiwi_index:"3"`
}

func DecodeVectorData(b *gokiwi.Buffer) (res *VectorData, err error) {
	res = &VectorData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.VectorNetworkBlob, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.NormalizedSize, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StyleOverrideTable = values
			}
		}
	}
	return
}

type GUIDPath struct {
	Guids []*GUID `kiwi_index:"1"`
}

func DecodeGUIDPath(b *gokiwi.Buffer) (res *GUIDPath, err error) {
	res = &GUIDPath{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Guids = values
			}
		}
	}
	return
}

type SymbolData struct {
	SymbolId           *GUID         `kiwi_index:"1"`
	SymbolOverrides    []*NodeChange `kiwi_index:"2"`
	UniformScaleFactor float64       `kiwi_index:"3"`
}

func DecodeSymbolData(b *gokiwi.Buffer) (res *SymbolData, err error) {
	res = &SymbolData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SymbolId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.SymbolOverrides = values
			}
		case 3:
			res.UniformScaleFactor, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type GUIDPathMapping struct {
	Id   *GUID     `kiwi_index:"1"`
	Path *GUIDPath `kiwi_index:"2"`
}

func DecodeGUIDPathMapping(b *gokiwi.Buffer) (res *GUIDPathMapping, err error) {
	res = &GUIDPathMapping{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Path, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type NodeGenerationData struct {
	Overrides             []*NodeChange `kiwi_index:"1"`
	UseFineGrainedSyncing bool          `kiwi_index:"2"`
	DiffOnlyRemovals      []*NodeChange `kiwi_index:"3"`
}

func DecodeNodeGenerationData(b *gokiwi.Buffer) (res *NodeGenerationData, err error) {
	res = &NodeGenerationData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Overrides = values
			}
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.UseFineGrainedSyncing = v != 0
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DiffOnlyRemovals = values
			}
		}
	}
	return
}

type DerivedImmutableFrameData struct {
	Overrides []*NodeChange `kiwi_index:"1"`
	Version   uint          `kiwi_index:"2"`
}

func DecodeDerivedImmutableFrameData(b *gokiwi.Buffer) (res *DerivedImmutableFrameData, err error) {
	res = &DerivedImmutableFrameData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Overrides = values
			}
		case 2:
			res.Version, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AssetIdMap struct {
	Entries []*AssetIdEntry `kiwi_index:"1"`
}

func DecodeAssetIdMap(b *gokiwi.Buffer) (res *AssetIdMap, err error) {
	res = &AssetIdMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*AssetIdEntry, size)
				for i := range size {
					v, err := DecodeAssetIdEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type AssetIdEntry struct {
	AssetKey string   `kiwi_index:"1"`
	AssetId  *AssetId `kiwi_index:"2"`
}

func DecodeAssetIdEntry(b *gokiwi.Buffer) (res *AssetIdEntry, err error) {
	res = &AssetIdEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.AssetKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetId, err = DecodeAssetId(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AssetRef struct {
	Key     string `kiwi_index:"1"`
	Version string `kiwi_index:"2"`
}

func DecodeAssetRef(b *gokiwi.Buffer) (res *AssetRef, err error) {
	res = &AssetRef{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Version, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AssetId struct {
	Guid          *GUID          `kiwi_index:"1"`
	AssetRef      *AssetRef      `kiwi_index:"2"`
	StateGroupId  *StateGroupId  `kiwi_index:"3"`
	StyleId       *StyleId       `kiwi_index:"4"`
	SymbolId      *SymbolId      `kiwi_index:"5"`
	VariableId    *VariableID    `kiwi_index:"6"`
	VariableSetId *VariableSetID `kiwi_index:"7"`
}

func DecodeAssetId(b *gokiwi.Buffer) (res *AssetId, err error) {
	res = &AssetId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.StateGroupId, err = DecodeStateGroupId(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.StyleId, err = DecodeStyleId(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.SymbolId, err = DecodeSymbolId(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.VariableId, err = DecodeVariableID(b)
			if err != nil {
				return nil, err
			}
		case 7:
			res.VariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type StateGroupId struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeStateGroupId(b *gokiwi.Buffer) (res *StateGroupId, err error) {
	res = &StateGroupId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type StyleId struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeStyleId(b *gokiwi.Buffer) (res *StyleId, err error) {
	res = &StyleId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SymbolId struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeSymbolId(b *gokiwi.Buffer) (res *SymbolId, err error) {
	res = &SymbolId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableID struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeVariableID(b *gokiwi.Buffer) (res *VariableID, err error) {
	res = &VariableID{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableOverrideId struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeVariableOverrideId(b *gokiwi.Buffer) (res *VariableOverrideId, err error) {
	res = &VariableOverrideId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableSetID struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeVariableSetID(b *gokiwi.Buffer) (res *VariableSetID, err error) {
	res = &VariableSetID{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ModuleId struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeModuleId(b *gokiwi.Buffer) (res *ModuleId, err error) {
	res = &ModuleId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ThemeID struct {
	Guid     *GUID     `kiwi_index:"1"`
	AssetRef *AssetRef `kiwi_index:"2"`
}

func DecodeThemeID(b *gokiwi.Buffer) (res *ThemeID, err error) {
	res = &ThemeID{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AssetRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type FlappType int

const (
	FlappTypePoll      FlappType = 0
	FlappTypeEmbed     FlappType = 1
	FlappTypeFacepile  FlappType = 2
	FlappTypeAlignment FlappType = 3
	FlappTypeYoutube   FlappType = 4
)

type SlideThemeData struct {
	ThemeId *ThemeID `kiwi_index:"1"`
	Version string   `kiwi_index:"2"`
}

func DecodeSlideThemeData(b *gokiwi.Buffer) (res *SlideThemeData, err error) {
	res = &SlideThemeData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ThemeId, err = DecodeThemeID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Version, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SlideThemeProps struct {
	ThemeVersion                  string         `kiwi_index:"1"`
	VariableSetId                 *VariableSetID `kiwi_index:"2"`
	TextStyleIds                  []*StyleId     `kiwi_index:"3"`
	IsTextColorManuallySelected   bool           `kiwi_index:"4"`
	IsBorderColorManuallySelected bool           `kiwi_index:"5"`
	SubscribedThemeRef            *AssetRef      `kiwi_index:"6"`
}

func DecodeSlideThemeProps(b *gokiwi.Buffer) (res *SlideThemeProps, err error) {
	res = &SlideThemeProps{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ThemeVersion, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.VariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*StyleId, size)
				for i := range size {
					v, err := DecodeStyleId(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.TextStyleIds = values
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsTextColorManuallySelected = v != 0
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsBorderColorManuallySelected = v != 0
		case 6:
			res.SubscribedThemeRef, err = DecodeAssetRef(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SlideThemeMap struct {
	Entries []*SlideThemeMapEntry `kiwi_index:"1"`
}

func DecodeSlideThemeMap(b *gokiwi.Buffer) (res *SlideThemeMap, err error) {
	res = &SlideThemeMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*SlideThemeMapEntry, size)
				for i := range size {
					v, err := DecodeSlideThemeMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type SlideThemeMapEntry struct {
	ThemeId    *ThemeID         `kiwi_index:"1"`
	ThemeProps *SlideThemeProps `kiwi_index:"2"`
}

func DecodeSlideThemeMapEntry(b *gokiwi.Buffer) (res *SlideThemeMapEntry, err error) {
	res = &SlideThemeMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ThemeId, err = DecodeThemeID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.ThemeProps, err = DecodeSlideThemeProps(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SharedSymbolReference struct {
	FileKey                      string             `kiwi_index:"1"`
	SymbolId                     *GUID              `kiwi_index:"2"`
	VersionHash                  string             `kiwi_index:"3"`
	GuidPathMappings             []*GUIDPathMapping `kiwi_index:"4"`
	Bytes                        []byte             `kiwi_index:"5"`
	LibraryGuidToSubscribingGuid []*GUIDMapping     `kiwi_index:"6"`
	ComponentKey                 string             `kiwi_index:"7"`
	UnflatteningMappings         []*GUIDPathMapping `kiwi_index:"8"`
	IsUnflattened                bool               `kiwi_index:"9"`
}

func DecodeSharedSymbolReference(b *gokiwi.Buffer) (res *SharedSymbolReference, err error) {
	res = &SharedSymbolReference{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.FileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.SymbolId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.VersionHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPathMapping, size)
				for i := range size {
					v, err := DecodeGUIDPathMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.GuidPathMappings = values
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]byte, size)
				for i := range size {
					values[i], err = b.ReadByte()
					if err != nil {
						return nil, err
					}
				}
				res.Bytes = values
			}
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDMapping, size)
				for i := range size {
					v, err := DecodeGUIDMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.LibraryGuidToSubscribingGuid = values
			}
		case 7:
			res.ComponentKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 8:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPathMapping, size)
				for i := range size {
					v, err := DecodeGUIDPathMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.UnflatteningMappings = values
			}
		case 9:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsUnflattened = v != 0
		}
	}
	return
}

type SharedComponentMasterData struct {
	ComponentKey                        string             `kiwi_index:"1"`
	PublishingGuidPathToTeamLibraryGuid []*GUIDPathMapping `kiwi_index:"2"`
	IsUnflattened                       bool               `kiwi_index:"3"`
}

func DecodeSharedComponentMasterData(b *gokiwi.Buffer) (res *SharedComponentMasterData, err error) {
	res = &SharedComponentMasterData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ComponentKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPathMapping, size)
				for i := range size {
					v, err := DecodeGUIDPathMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PublishingGuidPathToTeamLibraryGuid = values
			}
		case 3:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsUnflattened = v != 0
		}
	}
	return
}

type InstanceOverrideStash struct {
	OverridePathOfSwappedInstance *GUIDPath     `kiwi_index:"1"`
	ComponentKey                  string        `kiwi_index:"2"`
	Overrides                     []*NodeChange `kiwi_index:"3"`
}

func DecodeInstanceOverrideStash(b *gokiwi.Buffer) (res *InstanceOverrideStash, err error) {
	res = &InstanceOverrideStash{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.OverridePathOfSwappedInstance, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.ComponentKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Overrides = values
			}
		}
	}
	return
}

type InstanceOverrideStashV2 struct {
	OverridePathOfSwappedInstance *GUIDPath     `kiwi_index:"1"`
	LocalSymbolId                 *GUID         `kiwi_index:"2"`
	Overrides                     []*NodeChange `kiwi_index:"3"`
}

func DecodeInstanceOverrideStashV2(b *gokiwi.Buffer) (res *InstanceOverrideStashV2, err error) {
	res = &InstanceOverrideStashV2{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.OverridePathOfSwappedInstance, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.LocalSymbolId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Overrides = values
			}
		}
	}
	return
}

type Effect struct {
	Type                 EffectType    `kiwi_index:"1"`
	Color                *Color        `kiwi_index:"2"`
	Offset               *Vector       `kiwi_index:"3"`
	Radius               float64       `kiwi_index:"4"`
	Visible              bool          `kiwi_index:"5"`
	BlendMode            BlendMode     `kiwi_index:"6"`
	Spread               float64       `kiwi_index:"7"`
	ShowShadowBehindNode bool          `kiwi_index:"8"`
	RadiusVar            *VariableData `kiwi_index:"9"`
	ColorVar             *VariableData `kiwi_index:"10"`
	SpreadVar            *VariableData `kiwi_index:"11"`
	XVar                 *VariableData `kiwi_index:"12"`
	YVar                 *VariableData `kiwi_index:"13"`
}

func DecodeEffect(b *gokiwi.Buffer) (res *Effect, err error) {
	res = &Effect{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = EffectType(v)
		case 2:
			res.Color, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.Offset, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.Radius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Visible = v != 0
		case 6:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.BlendMode = BlendMode(v)
		case 7:
			res.Spread, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 8:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ShowShadowBehindNode = v != 0
		case 9:
			res.RadiusVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 10:
			res.ColorVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 11:
			res.SpreadVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 12:
			res.XVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 13:
			res.YVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TransitionInfo struct {
	Type     TransitionType `kiwi_index:"1"`
	Duration float64        `kiwi_index:"2"`
}

func DecodeTransitionInfo(b *gokiwi.Buffer) (res *TransitionInfo, err error) {
	res = &TransitionInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = TransitionType(v)
		case 2:
			res.Duration, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PrototypeDeviceType int

const (
	PrototypeDeviceTypeNone         PrototypeDeviceType = 0
	PrototypeDeviceTypePreset       PrototypeDeviceType = 1
	PrototypeDeviceTypeCustom       PrototypeDeviceType = 2
	PrototypeDeviceTypePresentation PrototypeDeviceType = 3
)

type DeviceRotation int

const (
	DeviceRotationNone  DeviceRotation = 0
	DeviceRotationCcw90 DeviceRotation = 1
)

type PrototypeDevice struct {
	Type             PrototypeDeviceType `kiwi_index:"1"`
	Size             *Vector             `kiwi_index:"2"`
	PresetIdentifier string              `kiwi_index:"3"`
	Rotation         DeviceRotation      `kiwi_index:"4"`
}

func DecodePrototypeDevice(b *gokiwi.Buffer) (res *PrototypeDevice, err error) {
	res = &PrototypeDevice{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = PrototypeDeviceType(v)
		case 2:
			res.Size, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.PresetIdentifier, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Rotation = DeviceRotation(v)
		}
	}
	return
}

type OverlayPositionType int

const (
	OverlayPositionTypeCenter       OverlayPositionType = 0
	OverlayPositionTypeTopLeft      OverlayPositionType = 1
	OverlayPositionTypeTopCenter    OverlayPositionType = 2
	OverlayPositionTypeTopRight     OverlayPositionType = 3
	OverlayPositionTypeBottomLeft   OverlayPositionType = 4
	OverlayPositionTypeBottomCenter OverlayPositionType = 5
	OverlayPositionTypeBottomRight  OverlayPositionType = 6
	OverlayPositionTypeManual       OverlayPositionType = 7
)

type OverlayBackgroundInteraction int

const (
	OverlayBackgroundInteractionNone                OverlayBackgroundInteraction = 0
	OverlayBackgroundInteractionCloseOnClickOutside OverlayBackgroundInteraction = 1
)

type OverlayBackgroundType int

const (
	OverlayBackgroundTypeNone       OverlayBackgroundType = 0
	OverlayBackgroundTypeSolidColor OverlayBackgroundType = 1
)

type OverlayBackgroundAppearance struct {
	BackgroundType  OverlayBackgroundType `kiwi_index:"1"`
	BackgroundColor *Color                `kiwi_index:"2"`
}

func DecodeOverlayBackgroundAppearance(b *gokiwi.Buffer) (res *OverlayBackgroundAppearance, err error) {
	res = &OverlayBackgroundAppearance{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.BackgroundType = OverlayBackgroundType(v)
		case 2:
			res.BackgroundColor, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type NavigationType int

const (
	NavigationTypeNavigate  NavigationType = 0
	NavigationTypeOverlay   NavigationType = 1
	NavigationTypeSwap      NavigationType = 2
	NavigationTypeSwapState NavigationType = 3
	NavigationTypeScrollTo  NavigationType = 4
)

type ExportColorProfile int

const (
	ExportColorProfileDocument    ExportColorProfile = 0
	ExportColorProfileSrgb        ExportColorProfile = 1
	ExportColorProfileDisplayP3V4 ExportColorProfile = 2
)

type ExportSettings struct {
	Suffix              string             `kiwi_index:"1"`
	ImageType           ImageType          `kiwi_index:"2"`
	Constraint          *ExportConstraint  `kiwi_index:"3"`
	SvgDataName         bool               `kiwi_index:"4"`
	SvgIdMode           ExportSVGIDMode    `kiwi_index:"5"`
	SvgOutlineText      bool               `kiwi_index:"6"`
	ContentsOnly        bool               `kiwi_index:"7"`
	SvgForceStrokeMasks bool               `kiwi_index:"8"`
	UseAbsoluteBounds   bool               `kiwi_index:"9"`
	ColorProfile        ExportColorProfile `kiwi_index:"10"`
	Quality             float64            `kiwi_index:"11"`
}

func DecodeExportSettings(b *gokiwi.Buffer) (res *ExportSettings, err error) {
	res = &ExportSettings{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Suffix, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ImageType = ImageType(v)
		case 3:
			res.Constraint, err = DecodeExportConstraint(b)
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.SvgDataName = v != 0
		case 5:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.SvgIdMode = ExportSVGIDMode(v)
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.SvgOutlineText = v != 0
		case 7:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ContentsOnly = v != 0
		case 8:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.SvgForceStrokeMasks = v != 0
		case 9:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.UseAbsoluteBounds = v != 0
		case 10:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ColorProfile = ExportColorProfile(v)
		case 11:
			res.Quality, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ExportSVGIDMode int

const (
	ExportSVGIDModeIfNeeded ExportSVGIDMode = 0
	ExportSVGIDModeAlways   ExportSVGIDMode = 1
)

type LayoutGrid struct {
	Type           LayoutGridType    `kiwi_index:"1"`
	Axis           Axis              `kiwi_index:"2"`
	Visible        bool              `kiwi_index:"3"`
	NumSections    int               `kiwi_index:"4"`
	Offset         float64           `kiwi_index:"5"`
	SectionSize    float64           `kiwi_index:"6"`
	GutterSize     float64           `kiwi_index:"7"`
	Color          *Color            `kiwi_index:"8"`
	Pattern        LayoutGridPattern `kiwi_index:"9"`
	NumSectionsVar *VariableData     `kiwi_index:"10"`
	OffsetVar      *VariableData     `kiwi_index:"11"`
	SectionSizeVar *VariableData     `kiwi_index:"12"`
	GutterSizeVar  *VariableData     `kiwi_index:"13"`
}

func DecodeLayoutGrid(b *gokiwi.Buffer) (res *LayoutGrid, err error) {
	res = &LayoutGrid{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = LayoutGridType(v)
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Axis = Axis(v)
		case 3:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Visible = v != 0
		case 4:
			res.NumSections, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 5:
			res.Offset, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 6:
			res.SectionSize, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.GutterSize, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 8:
			res.Color, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 9:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Pattern = LayoutGridPattern(v)
		case 10:
			res.NumSectionsVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 11:
			res.OffsetVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 12:
			res.SectionSizeVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 13:
			res.GutterSizeVar, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Guide struct {
	Axis   Axis    `kiwi_index:"1"`
	Offset float64 `kiwi_index:"2"`
	Guid   *GUID   `kiwi_index:"3"`
}

func DecodeGuide(b *gokiwi.Buffer) (res *Guide, err error) {
	res = &Guide{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Axis = Axis(v)
		case 2:
			res.Offset, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Path struct {
	WindingRule  WindingRule `kiwi_index:"1"`
	CommandsBlob uint        `kiwi_index:"2"`
	StyleId      uint        `kiwi_index:"3"`
}

func DecodePath(b *gokiwi.Buffer) (res *Path, err error) {
	res = &Path{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.WindingRule = WindingRule(v)
		case 2:
			res.CommandsBlob, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.StyleId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type StyleType int

const (
	StyleTypeNone   StyleType = 0
	StyleTypeFill   StyleType = 1
	StyleTypeStroke StyleType = 2
	StyleTypeText   StyleType = 3
	StyleTypeEffect StyleType = 4
	StyleTypeExport StyleType = 5
	StyleTypeGrid   StyleType = 6
)

type SharedStyleReference struct {
	StyleKey    string `kiwi_index:"1"`
	VersionHash string `kiwi_index:"2"`
}

func DecodeSharedStyleReference(b *gokiwi.Buffer) (res *SharedStyleReference, err error) {
	res = &SharedStyleReference{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StyleKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.VersionHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SharedStyleMasterData struct {
	StyleKey     string `kiwi_index:"1"`
	SortPosition string `kiwi_index:"2"`
	FileKey      string `kiwi_index:"3"`
}

func DecodeSharedStyleMasterData(b *gokiwi.Buffer) (res *SharedStyleMasterData, err error) {
	res = &SharedStyleMasterData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StyleKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.SortPosition, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.FileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ScrollBehavior int

const (
	ScrollBehaviorScrolls                        ScrollBehavior = 0
	ScrollBehaviorFixedWhenChildOfScrollingFrame ScrollBehavior = 1
	ScrollBehaviorStickyScrolls                  ScrollBehavior = 2
)

type ArcData struct {
	StartingAngle float64 `kiwi_index:"1"`
	EndingAngle   float64 `kiwi_index:"2"`
	InnerRadius   float64 `kiwi_index:"3"`
}

func DecodeArcData(b *gokiwi.Buffer) (res *ArcData, err error) {
	res = &ArcData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StartingAngle, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 2:
			res.EndingAngle, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			res.InnerRadius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SymbolLink struct {
	Uri         string `kiwi_index:"1"`
	DisplayName string `kiwi_index:"2"`
	DisplayText string `kiwi_index:"3"`
}

func DecodeSymbolLink(b *gokiwi.Buffer) (res *SymbolLink, err error) {
	res = &SymbolLink{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Uri, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.DisplayName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.DisplayText, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PluginData struct {
	PluginId string `kiwi_index:"1"`
	Value    string `kiwi_index:"2"`
	Key      string `kiwi_index:"3"`
}

func DecodePluginData(b *gokiwi.Buffer) (res *PluginData, err error) {
	res = &PluginData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.PluginId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Value, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PluginRelaunchData struct {
	PluginId  string `kiwi_index:"1"`
	Message   string `kiwi_index:"2"`
	Command   string `kiwi_index:"3"`
	IsDeleted bool   `kiwi_index:"4"`
}

func DecodePluginRelaunchData(b *gokiwi.Buffer) (res *PluginRelaunchData, err error) {
	res = &PluginRelaunchData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.PluginId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Message, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Command, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsDeleted = v != 0
		}
	}
	return
}

type MultiplayerFieldVersion struct {
	Counter   uint `kiwi_index:"1"`
	SessionId uint `kiwi_index:"2"`
}

func DecodeMultiplayerFieldVersion(b *gokiwi.Buffer) (res *MultiplayerFieldVersion, err error) {
	res = &MultiplayerFieldVersion{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Counter, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ConnectorMagnet int

const (
	ConnectorMagnetNone           ConnectorMagnet = 0
	ConnectorMagnetAuto           ConnectorMagnet = 1
	ConnectorMagnetTop            ConnectorMagnet = 2
	ConnectorMagnetLeft           ConnectorMagnet = 3
	ConnectorMagnetBottom         ConnectorMagnet = 4
	ConnectorMagnetRight          ConnectorMagnet = 5
	ConnectorMagnetCenter         ConnectorMagnet = 6
	ConnectorMagnetAutoHorizontal ConnectorMagnet = 7
)

type ConnectorEndpoint struct {
	EndpointNodeId *GUID           `kiwi_index:"1"`
	Position       *Vector         `kiwi_index:"2"`
	Magnet         ConnectorMagnet `kiwi_index:"3"`
}

func DecodeConnectorEndpoint(b *gokiwi.Buffer) (res *ConnectorEndpoint, err error) {
	res = &ConnectorEndpoint{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.EndpointNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Position, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Magnet = ConnectorMagnet(v)
		}
	}
	return
}

type ConnectorControlPoint struct {
	Position *Vector `kiwi_index:"1"`
	Axis     *Vector `kiwi_index:"2"`
}

func DecodeConnectorControlPoint(b *gokiwi.Buffer) (res *ConnectorControlPoint, err error) {
	res = &ConnectorControlPoint{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Position, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Axis, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ConnectorTextSection int

const (
	ConnectorTextSectionMiddleToStart ConnectorTextSection = 0
	ConnectorTextSectionMiddleToEnd   ConnectorTextSection = 1
)

type ConnectorOffAxisOffset int

const (
	ConnectorOffAxisOffsetNone  ConnectorOffAxisOffset = 0
	ConnectorOffAxisOffsetAbove ConnectorOffAxisOffset = 1
	ConnectorOffAxisOffsetBelow ConnectorOffAxisOffset = 2
)

type ConnectorTextMidpoint struct {
	Section       ConnectorTextSection   `kiwi_index:"1"`
	Offset        float64                `kiwi_index:"2"`
	OffAxisOffset ConnectorOffAxisOffset `kiwi_index:"3"`
}

func DecodeConnectorTextMidpoint(b *gokiwi.Buffer) (res *ConnectorTextMidpoint, err error) {
	res = &ConnectorTextMidpoint{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Section = ConnectorTextSection(v)
		case 2:
			res.Offset, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.OffAxisOffset = ConnectorOffAxisOffset(v)
		}
	}
	return
}

type ConnectorLineStyle int

const (
	ConnectorLineStyleElbowed  ConnectorLineStyle = 0
	ConnectorLineStyleStraight ConnectorLineStyle = 1
	ConnectorLineStyleCurved   ConnectorLineStyle = 2
)

type ConnectorType int

const (
	ConnectorTypeManual  ConnectorType = 0
	ConnectorTypeDiagram ConnectorType = 1
)

type AnnotationPropertyType int

const (
	AnnotationPropertyTypeFill                AnnotationPropertyType = 0
	AnnotationPropertyTypeStroke              AnnotationPropertyType = 1
	AnnotationPropertyTypeWidth               AnnotationPropertyType = 2
	AnnotationPropertyTypeHeight              AnnotationPropertyType = 3
	AnnotationPropertyTypeMinWidth            AnnotationPropertyType = 4
	AnnotationPropertyTypeMinHeight           AnnotationPropertyType = 5
	AnnotationPropertyTypeMaxWidth            AnnotationPropertyType = 6
	AnnotationPropertyTypeMaxHeight           AnnotationPropertyType = 7
	AnnotationPropertyTypeStrokeWidth         AnnotationPropertyType = 8
	AnnotationPropertyTypeCornerRadius        AnnotationPropertyType = 9
	AnnotationPropertyTypeEffect              AnnotationPropertyType = 10
	AnnotationPropertyTypeTextStyle           AnnotationPropertyType = 11
	AnnotationPropertyTypeTextAlignHorizontal AnnotationPropertyType = 12
	AnnotationPropertyTypeFontFamily          AnnotationPropertyType = 13
	AnnotationPropertyTypeFontSize            AnnotationPropertyType = 14
	AnnotationPropertyTypeFontWeight          AnnotationPropertyType = 15
	AnnotationPropertyTypeLineHeight          AnnotationPropertyType = 16
	AnnotationPropertyTypeLetterSpacing       AnnotationPropertyType = 17
	AnnotationPropertyTypeStackSpacing        AnnotationPropertyType = 18
	AnnotationPropertyTypeStackPadding        AnnotationPropertyType = 19
	AnnotationPropertyTypeStackMode           AnnotationPropertyType = 20
	AnnotationPropertyTypeStackAlignment      AnnotationPropertyType = 21
	AnnotationPropertyTypeOpacity             AnnotationPropertyType = 22
	AnnotationPropertyTypeComponent           AnnotationPropertyType = 23
	AnnotationPropertyTypeFontStyle           AnnotationPropertyType = 24
)

type AnnotationProperty struct {
	Type AnnotationPropertyType `kiwi_index:"1"`
}

func DecodeAnnotationProperty(b *gokiwi.Buffer) (res *AnnotationProperty, err error) {
	res = &AnnotationProperty{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = AnnotationPropertyType(v)
		}
	}
	return
}

type Annotation struct {
	Label      string                `kiwi_index:"1"`
	Properties []*AnnotationProperty `kiwi_index:"2"`
}

func DecodeAnnotation(b *gokiwi.Buffer) (res *Annotation, err error) {
	res = &Annotation{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Label, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*AnnotationProperty, size)
				for i := range size {
					v, err := DecodeAnnotationProperty(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Properties = values
			}
		}
	}
	return
}

type AnnotationMeasurementNodeSide int

const (
	AnnotationMeasurementNodeSideTop    AnnotationMeasurementNodeSide = 0
	AnnotationMeasurementNodeSideBottom AnnotationMeasurementNodeSide = 1
	AnnotationMeasurementNodeSideLeft   AnnotationMeasurementNodeSide = 2
	AnnotationMeasurementNodeSideRight  AnnotationMeasurementNodeSide = 3
)

type AnnotationMeasurement struct {
	Id                  *GUID                         `kiwi_index:"1"`
	FromNode            *GUID                         `kiwi_index:"2"`
	ToNode              *GUID                         `kiwi_index:"3"`
	FromNodeSide        AnnotationMeasurementNodeSide `kiwi_index:"4"`
	ToSameSide          bool                          `kiwi_index:"5"`
	InnerOffsetRelative float64                       `kiwi_index:"6"`
	OuterOffsetFixed    float64                       `kiwi_index:"7"`
	ToNodeStablePath    *GUIDPath                     `kiwi_index:"8"`
	FreeText            string                        `kiwi_index:"9"`
}

func DecodeAnnotationMeasurement(b *gokiwi.Buffer) (res *AnnotationMeasurement, err error) {
	res = &AnnotationMeasurement{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.FromNode, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.ToNode, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FromNodeSide = AnnotationMeasurementNodeSide(v)
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ToSameSide = v != 0
		case 6:
			res.InnerOffsetRelative, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.OuterOffsetFixed, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 8:
			res.ToNodeStablePath, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 9:
			res.FreeText, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type LibraryMoveInfo struct {
	OldKey       string `kiwi_index:"1"`
	PasteFileKey string `kiwi_index:"2"`
}

func DecodeLibraryMoveInfo(b *gokiwi.Buffer) (res *LibraryMoveInfo, err error) {
	res = &LibraryMoveInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.OldKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.PasteFileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type LibraryMoveHistoryItem struct {
	SourceNodeId       *GUID  `kiwi_index:"1"`
	SourceComponentKey string `kiwi_index:"2"`
}

func DecodeLibraryMoveHistoryItem(b *gokiwi.Buffer) (res *LibraryMoveHistoryItem, err error) {
	res = &LibraryMoveHistoryItem{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SourceNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.SourceComponentKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type DeveloperRelatedLink struct {
	NodeId   string `kiwi_index:"1"`
	FileKey  string `kiwi_index:"2"`
	LinkName string `kiwi_index:"3"`
	LinkUrl  string `kiwi_index:"4"`
}

func DecodeDeveloperRelatedLink(b *gokiwi.Buffer) (res *DeveloperRelatedLink, err error) {
	res = &DeveloperRelatedLink{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.FileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.LinkName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.LinkUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type WidgetPointer struct {
	NodeId *GUID `kiwi_index:"1"`
}

func DecodeWidgetPointer(b *gokiwi.Buffer) (res *WidgetPointer, err error) {
	res = &WidgetPointer{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type EditInfo struct {
	TimestampIso8601 string `kiwi_index:"1"`
	UserId           string `kiwi_index:"2"`
	LastEditedAt     uint   `kiwi_index:"3"`
	CreatedAt        uint   `kiwi_index:"4"`
}

func DecodeEditInfo(b *gokiwi.Buffer) (res *EditInfo, err error) {
	res = &EditInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.TimestampIso8601, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.UserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.LastEditedAt, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			res.CreatedAt, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type EditorType int

const (
	EditorTypeDesign     EditorType = 0
	EditorTypeWhiteboard EditorType = 1
	EditorTypeSlides     EditorType = 2
	EditorTypeDevHandoff EditorType = 3
	EditorTypeSites      EditorType = 4
)

type MaskType int

const (
	MaskTypeAlpha     MaskType = 0
	MaskTypeOutline   MaskType = 1
	MaskTypeLuminance MaskType = 2
)

type ModuleType int

const (
	ModuleTypeNone       ModuleType = 0
	ModuleTypeSingleNode ModuleType = 1
	ModuleTypeMultiNode  ModuleType = 2
)

type SectionStatus int

const (
	SectionStatusNone      SectionStatus = 0
	SectionStatusBuild     SectionStatus = 1
	SectionStatusCompleted SectionStatus = 2
)

type SectionStatusInfo struct {
	Status                  SectionStatus `kiwi_index:"1"`
	LastUpdateUnixTimestamp uint          `kiwi_index:"2"`
	Description             string        `kiwi_index:"3"`
	UserId                  string        `kiwi_index:"4"`
}

func DecodeSectionStatusInfo(b *gokiwi.Buffer) (res *SectionStatusInfo, err error) {
	res = &SectionStatusInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Status = SectionStatus(v)
		case 2:
			res.LastUpdateUnixTimestamp, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Description, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.UserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type NodeChange struct {
	Guid                                  *GUID                           `kiwi_index:"1"`
	GuidTag                               uint                            `kiwi_index:"53"`
	Phase                                 NodePhase                       `kiwi_index:"2"`
	PhaseTag                              uint                            `kiwi_index:"54"`
	ParentIndex                           *ParentIndex                    `kiwi_index:"3"`
	ParentIndexTag                        uint                            `kiwi_index:"55"`
	Type                                  NodeType                        `kiwi_index:"4"`
	TypeTag                               uint                            `kiwi_index:"56"`
	Name                                  string                          `kiwi_index:"5"`
	NameTag                               uint                            `kiwi_index:"57"`
	IsPublishable                         bool                            `kiwi_index:"174"`
	Description                           string                          `kiwi_index:"318"`
	LibraryMoveInfo                       *LibraryMoveInfo                `kiwi_index:"256"`
	LibraryMoveHistory                    []*LibraryMoveHistoryItem       `kiwi_index:"281"`
	Key                                   string                          `kiwi_index:"319"`
	FileAssetIds                          *AssetIdMap                     `kiwi_index:"383"`
	StyleId                               uint                            `kiwi_index:"49"`
	StyleIdTag                            uint                            `kiwi_index:"101"`
	IsSoftDeletedStyle                    bool                            `kiwi_index:"176"`
	IsNonUpdateable                       bool                            `kiwi_index:"177"`
	IsFillStyle                           bool                            `kiwi_index:"157"`
	IsStrokeStyle                         bool                            `kiwi_index:"161"`
	IsOverrideOverTextStyle               bool                            `kiwi_index:"376"`
	StyleType                             StyleType                       `kiwi_index:"163"`
	StyleDescription                      string                          `kiwi_index:"191"`
	Version                               string                          `kiwi_index:"171"`
	SharedStyleMasterData                 *SharedStyleMasterData          `kiwi_index:"172"`
	SharedStyleReference                  *SharedStyleReference           `kiwi_index:"173"`
	UserFacingVersion                     string                          `kiwi_index:"399"`
	SortPosition                          string                          `kiwi_index:"320"`
	OjansSuperSecretNodeField             *SharedStyleMasterData          `kiwi_index:"345"`
	SevMoonlitLilyData                    *SharedStyleMasterData          `kiwi_index:"348"`
	InheritFillStyleId                    *GUID                           `kiwi_index:"158"`
	InheritStrokeStyleId                  *GUID                           `kiwi_index:"162"`
	InheritTextStyleId                    *GUID                           `kiwi_index:"167"`
	InheritExportStyleId                  *GUID                           `kiwi_index:"168"`
	InheritEffectStyleId                  *GUID                           `kiwi_index:"169"`
	InheritGridStyleId                    *GUID                           `kiwi_index:"170"`
	InheritFillStyleIdForStroke           *GUID                           `kiwi_index:"185"`
	StyleIdForFill                        *StyleId                        `kiwi_index:"332"`
	StyleIdForStrokeFill                  *StyleId                        `kiwi_index:"333"`
	StyleIdForText                        *StyleId                        `kiwi_index:"334"`
	StyleIdForEffect                      *StyleId                        `kiwi_index:"335"`
	StyleIdForGrid                        *StyleId                        `kiwi_index:"336"`
	BackgroundPaints                      []*Paint                        `kiwi_index:"193"`
	InheritFillStyleIdForBackground       *GUID                           `kiwi_index:"194"`
	IsStateGroup                          bool                            `kiwi_index:"225"`
	StateGroupPropertyValueOrders         []*StateGroupPropertyValueOrder `kiwi_index:"238"`
	SharedSymbolReference                 *SharedSymbolReference          `kiwi_index:"122"`
	IsSymbolPublishable                   bool                            `kiwi_index:"123"`
	SharedSymbolMappings                  []*GUIDPathMapping              `kiwi_index:"124"`
	SharedSymbolVersion                   string                          `kiwi_index:"126"`
	SharedComponentMasterData             *SharedComponentMasterData      `kiwi_index:"152"`
	SymbolDescription                     string                          `kiwi_index:"144"`
	UnflatteningMappings                  []*GUIDPathMapping              `kiwi_index:"164"`
	ForceUnflatteningMappings             []*GUIDPathMapping              `kiwi_index:"228"`
	PublishFile                           string                          `kiwi_index:"214"`
	SourceLibraryKey                      string                          `kiwi_index:"395"`
	PublishId                             *GUID                           `kiwi_index:"215"`
	ComponentKey                          string                          `kiwi_index:"216"`
	IsC2                                  bool                            `kiwi_index:"217"`
	PublishedVersion                      string                          `kiwi_index:"218"`
	OriginComponentKey                    string                          `kiwi_index:"252"`
	ComponentPropDefs                     []*ComponentPropDef             `kiwi_index:"266"`
	ComponentPropRefs                     []*ComponentPropRef             `kiwi_index:"267"`
	SymbolData                            *SymbolData                     `kiwi_index:"113"`
	SymbolDataTag                         uint                            `kiwi_index:"114"`
	DerivedSymbolData                     []*NodeChange                   `kiwi_index:"125"`
	NestedInstanceResizeEnabled           bool                            `kiwi_index:"394"`
	OverriddenSymbolId                    *GUID                           `kiwi_index:"143"`
	ComponentPropAssignments              []*ComponentPropAssignment      `kiwi_index:"268"`
	PropsAreBubbled                       bool                            `kiwi_index:"305"`
	OverrideStash                         []*InstanceOverrideStash        `kiwi_index:"248"`
	OverrideStashV2                       []*InstanceOverrideStashV2      `kiwi_index:"250"`
	GuidPath                              *GUIDPath                       `kiwi_index:"111"`
	GuidPathTag                           uint                            `kiwi_index:"112"`
	OverrideLevel                         int                             `kiwi_index:"321"`
	ModuleType                            ModuleType                      `kiwi_index:"382"`
	FontSize                              float64                         `kiwi_index:"21"`
	FontSizeTag                           uint                            `kiwi_index:"73"`
	ParagraphIndent                       float64                         `kiwi_index:"22"`
	ParagraphIndentTag                    uint                            `kiwi_index:"74"`
	ParagraphSpacing                      float64                         `kiwi_index:"23"`
	ParagraphSpacingTag                   uint                            `kiwi_index:"75"`
	TextAlignHorizontal                   TextAlignHorizontal             `kiwi_index:"32"`
	TextAlignHorizontalTag                uint                            `kiwi_index:"84"`
	TextAlignVertical                     TextAlignVertical               `kiwi_index:"33"`
	TextAlignVerticalTag                  uint                            `kiwi_index:"85"`
	TextCase                              TextCase                        `kiwi_index:"34"`
	TextCaseTag                           uint                            `kiwi_index:"86"`
	TextDecoration                        TextDecoration                  `kiwi_index:"35"`
	TextDecorationTag                     uint                            `kiwi_index:"87"`
	LineHeight                            *Number                         `kiwi_index:"40"`
	LineHeightTag                         uint                            `kiwi_index:"92"`
	FontName                              *FontName                       `kiwi_index:"41"`
	FontNameTag                           uint                            `kiwi_index:"93"`
	TextData                              *TextData                       `kiwi_index:"42"`
	TextDataTag                           uint                            `kiwi_index:"94"`
	DerivedTextData                       *DerivedTextData                `kiwi_index:"359"`
	FontVariantCommonLigatures            bool                            `kiwi_index:"127"`
	FontVariantContextualLigatures        bool                            `kiwi_index:"128"`
	FontVariantDiscretionaryLigatures     bool                            `kiwi_index:"129"`
	FontVariantHistoricalLigatures        bool                            `kiwi_index:"130"`
	FontVariantOrdinal                    bool                            `kiwi_index:"131"`
	FontVariantSlashedZero                bool                            `kiwi_index:"132"`
	FontVariantNumericFigure              FontVariantNumericFigure        `kiwi_index:"133"`
	FontVariantNumericSpacing             FontVariantNumericSpacing       `kiwi_index:"134"`
	FontVariantNumericFraction            FontVariantNumericFraction      `kiwi_index:"135"`
	FontVariantCaps                       FontVariantCaps                 `kiwi_index:"136"`
	FontVariantPosition                   FontVariantPosition             `kiwi_index:"137"`
	LetterSpacing                         *Number                         `kiwi_index:"165"`
	FontVersion                           string                          `kiwi_index:"202"`
	LeadingTrim                           LeadingTrim                     `kiwi_index:"322"`
	HangingPunctuation                    bool                            `kiwi_index:"337"`
	HangingList                           bool                            `kiwi_index:"339"`
	MaxLines                              int                             `kiwi_index:"351"`
	SectionStatus                         SectionStatus                   `kiwi_index:"352"`
	SectionStatusInfo                     *SectionStatusInfo              `kiwi_index:"355"`
	TextUserLayoutVersion                 uint                            `kiwi_index:"203"`
	TextExplicitLayoutVersion             uint                            `kiwi_index:"396"`
	ToggledOnOtFeatures                   []OpenTypeFeature               `kiwi_index:"205"`
	ToggledOffOtFeatures                  []OpenTypeFeature               `kiwi_index:"206"`
	Hyperlink                             *Hyperlink                      `kiwi_index:"223"`
	Mention                               *Mention                        `kiwi_index:"340"`
	FontVariations                        []*FontVariation                `kiwi_index:"260"`
	TextBidiVersion                       uint                            `kiwi_index:"279"`
	TextTruncation                        TextTruncation                  `kiwi_index:"280"`
	HasHadRtlText                         bool                            `kiwi_index:"292"`
	EmojiImageSet                         EmojiImageSet                   `kiwi_index:"391"`
	SlideThumbnailHash                    string                          `kiwi_index:"392"`
	Visible                               bool                            `kiwi_index:"6"`
	VisibleTag                            uint                            `kiwi_index:"58"`
	Locked                                bool                            `kiwi_index:"7"`
	LockedTag                             uint                            `kiwi_index:"59"`
	Opacity                               float64                         `kiwi_index:"8"`
	OpacityTag                            uint                            `kiwi_index:"60"`
	BlendMode                             BlendMode                       `kiwi_index:"9"`
	BlendModeTag                          uint                            `kiwi_index:"61"`
	Size                                  *Vector                         `kiwi_index:"11"`
	SizeTag                               uint                            `kiwi_index:"63"`
	Transform                             *Matrix                         `kiwi_index:"12"`
	TransformTag                          uint                            `kiwi_index:"64"`
	DashPattern                           []float64                       `kiwi_index:"13"`
	DashPatternTag                        uint                            `kiwi_index:"65"`
	Mask                                  bool                            `kiwi_index:"16"`
	MaskTag                               uint                            `kiwi_index:"68"`
	MaskIsOutline                         bool                            `kiwi_index:"18"`
	MaskIsOutlineTag                      uint                            `kiwi_index:"70"`
	MaskType                              MaskType                        `kiwi_index:"317"`
	BackgroundOpacity                     float64                         `kiwi_index:"19"`
	BackgroundOpacityTag                  uint                            `kiwi_index:"71"`
	CornerRadius                          float64                         `kiwi_index:"20"`
	CornerRadiusTag                       uint                            `kiwi_index:"72"`
	StrokeWeight                          float64                         `kiwi_index:"26"`
	StrokeWeightTag                       uint                            `kiwi_index:"78"`
	StrokeAlign                           StrokeAlign                     `kiwi_index:"29"`
	StrokeAlignTag                        uint                            `kiwi_index:"81"`
	StrokeCap                             StrokeCap                       `kiwi_index:"30"`
	StrokeCapTag                          uint                            `kiwi_index:"82"`
	StrokeJoin                            StrokeJoin                      `kiwi_index:"31"`
	StrokeJoinTag                         uint                            `kiwi_index:"83"`
	FillPaints                            []*Paint                        `kiwi_index:"38"`
	FillPaintsTag                         uint                            `kiwi_index:"90"`
	StrokePaints                          []*Paint                        `kiwi_index:"39"`
	StrokePaintsTag                       uint                            `kiwi_index:"91"`
	Effects                               []*Effect                       `kiwi_index:"43"`
	EffectsTag                            uint                            `kiwi_index:"95"`
	BackgroundColor                       *Color                          `kiwi_index:"50"`
	BackgroundColorTag                    uint                            `kiwi_index:"102"`
	FillGeometry                          []*Path                         `kiwi_index:"51"`
	FillGeometryTag                       uint                            `kiwi_index:"103"`
	StrokeGeometry                        []*Path                         `kiwi_index:"52"`
	StrokeGeometryTag                     uint                            `kiwi_index:"104"`
	TextDecorationFillPaints              []*Paint                        `kiwi_index:"411"`
	RectangleTopLeftCornerRadius          float64                         `kiwi_index:"145"`
	RectangleTopRightCornerRadius         float64                         `kiwi_index:"146"`
	RectangleBottomLeftCornerRadius       float64                         `kiwi_index:"147"`
	RectangleBottomRightCornerRadius      float64                         `kiwi_index:"148"`
	RectangleCornerRadiiIndependent       bool                            `kiwi_index:"149"`
	RectangleCornerToolIndependent        bool                            `kiwi_index:"150"`
	ProportionsConstrained                bool                            `kiwi_index:"151"`
	UseAbsoluteBounds                     bool                            `kiwi_index:"258"`
	BorderTopHidden                       bool                            `kiwi_index:"287"`
	BorderBottomHidden                    bool                            `kiwi_index:"288"`
	BorderLeftHidden                      bool                            `kiwi_index:"289"`
	BorderRightHidden                     bool                            `kiwi_index:"290"`
	BordersTakeSpace                      bool                            `kiwi_index:"294"`
	BorderTopWeight                       float64                         `kiwi_index:"295"`
	BorderBottomWeight                    float64                         `kiwi_index:"296"`
	BorderLeftWeight                      float64                         `kiwi_index:"297"`
	BorderRightWeight                     float64                         `kiwi_index:"298"`
	BorderStrokeWeightsIndependent        bool                            `kiwi_index:"299"`
	HorizontalConstraint                  ConstraintType                  `kiwi_index:"28"`
	HorizontalConstraintTag               uint                            `kiwi_index:"80"`
	StackMode                             StackMode                       `kiwi_index:"105"`
	StackModeTag                          uint                            `kiwi_index:"106"`
	StackSpacing                          float64                         `kiwi_index:"107"`
	StackSpacingTag                       uint                            `kiwi_index:"108"`
	StackPadding                          float64                         `kiwi_index:"109"`
	StackPaddingTag                       uint                            `kiwi_index:"110"`
	StackCounterAlign                     StackCounterAlign               `kiwi_index:"120"`
	StackJustify                          StackJustify                    `kiwi_index:"121"`
	StackAlign                            StackAlign                      `kiwi_index:"208"`
	StackHorizontalPadding                float64                         `kiwi_index:"209"`
	StackVerticalPadding                  float64                         `kiwi_index:"210"`
	StackWidth                            StackSize                       `kiwi_index:"211"`
	StackHeight                           StackSize                       `kiwi_index:"212"`
	StackPrimarySizing                    StackSize                       `kiwi_index:"229"`
	StackPrimaryAlignItems                StackJustify                    `kiwi_index:"230"`
	StackCounterAlignItems                StackAlign                      `kiwi_index:"231"`
	StackChildPrimaryGrow                 float64                         `kiwi_index:"232"`
	StackPaddingRight                     float64                         `kiwi_index:"233"`
	StackPaddingBottom                    float64                         `kiwi_index:"234"`
	StackChildAlignSelf                   StackCounterAlign               `kiwi_index:"236"`
	StackPositioning                      StackPositioning                `kiwi_index:"269"`
	StackReverseZIndex                    bool                            `kiwi_index:"271"`
	StackWrap                             StackWrap                       `kiwi_index:"323"`
	StackCounterSpacing                   float64                         `kiwi_index:"324"`
	MinSize                               *OptionalVector                 `kiwi_index:"325"`
	MaxSize                               *OptionalVector                 `kiwi_index:"326"`
	StackCounterAlignContent              StackCounterAlignContent        `kiwi_index:"343"`
	SortedMovingChildIndices              []int                           `kiwi_index:"406"`
	IsSnakeGameBoard                      bool                            `kiwi_index:"344"`
	TransitionNodeId                      *GUID                           `kiwi_index:"139"`
	PrototypeStartNodeId                  *GUID                           `kiwi_index:"140"`
	PrototypeBackgroundColor              *Color                          `kiwi_index:"141"`
	TransitionInfo                        *TransitionInfo                 `kiwi_index:"153"`
	TransitionType                        TransitionType                  `kiwi_index:"154"`
	TransitionDuration                    float64                         `kiwi_index:"155"`
	EasingType                            EasingType                      `kiwi_index:"156"`
	TransitionPreserveScroll              bool                            `kiwi_index:"181"`
	ConnectionType                        ConnectionType                  `kiwi_index:"182"`
	ConnectionUrl                         string                          `kiwi_index:"183"`
	PrototypeDevice                       *PrototypeDevice                `kiwi_index:"184"`
	InteractionType                       InteractionType                 `kiwi_index:"187"`
	TransitionTimeout                     float64                         `kiwi_index:"188"`
	InteractionMaintained                 bool                            `kiwi_index:"189"`
	InteractionDuration                   float64                         `kiwi_index:"190"`
	DestinationIsOverlay                  bool                            `kiwi_index:"192"`
	TransitionShouldSmartAnimate          bool                            `kiwi_index:"207"`
	PrototypeInteractions                 []*PrototypeInteraction         `kiwi_index:"226"`
	PrototypeStartingPoint                *PrototypeStartingPoint         `kiwi_index:"249"`
	PluginData                            []*PluginData                   `kiwi_index:"204"`
	PluginRelaunchData                    []*PluginRelaunchData           `kiwi_index:"219"`
	ConnectorStart                        *ConnectorEndpoint              `kiwi_index:"242"`
	ConnectorEnd                          *ConnectorEndpoint              `kiwi_index:"243"`
	ConnectorLineStyle                    ConnectorLineStyle              `kiwi_index:"244"`
	ConnectorStartCap                     StrokeCap                       `kiwi_index:"245"`
	ConnectorEndCap                       StrokeCap                       `kiwi_index:"246"`
	ConnectorControlPoints                []*ConnectorControlPoint        `kiwi_index:"253"`
	ConnectorTextMidpoint                 *ConnectorTextMidpoint          `kiwi_index:"255"`
	ConnectorType                         ConnectorType                   `kiwi_index:"373"`
	Annotations                           []*Annotation                   `kiwi_index:"369"`
	Measurements                          []*AnnotationMeasurement        `kiwi_index:"384"`
	ShapeWithTextType                     ShapeWithTextType               `kiwi_index:"241"`
	ShapeUserHeight                       float64                         `kiwi_index:"247"`
	DerivedImmutableFrameData             *DerivedImmutableFrameData      `kiwi_index:"254"`
	DerivedImmutableFrameDataVersion      *MultiplayerFieldVersion        `kiwi_index:"338"`
	NodeGenerationData                    *NodeGenerationData             `kiwi_index:"240"`
	CodeBlockLanguage                     CodeBlockLanguage               `kiwi_index:"259"`
	LinkPreviewData                       *LinkPreviewData                `kiwi_index:"278"`
	ShapeTruncates                        bool                            `kiwi_index:"282"`
	SectionContentsHidden                 bool                            `kiwi_index:"283"`
	VideoPlayback                         *VideoPlayback                  `kiwi_index:"300"`
	StampData                             *StampData                      `kiwi_index:"301"`
	SectionPresetInfo                     *SectionPresetInfo              `kiwi_index:"370"`
	PlatformShapeDefinition               *PlatformShapeDefinition        `kiwi_index:"409"`
	WidgetSyncedState                     *MultiplayerMap                 `kiwi_index:"273"`
	WidgetSyncCursor                      uint                            `kiwi_index:"274"`
	WidgetDerivedSubtreeCursor            *WidgetDerivedSubtreeCursor     `kiwi_index:"275"`
	WidgetCachedAncestor                  *WidgetPointer                  `kiwi_index:"276"`
	WidgetInputBehavior                   WidgetInputBehavior             `kiwi_index:"285"`
	WidgetTooltip                         string                          `kiwi_index:"286"`
	WidgetHoverStyle                      *WidgetHoverStyle               `kiwi_index:"291"`
	IsWidgetStickable                     bool                            `kiwi_index:"293"`
	ShouldHideCursorsOnWidgetHover        bool                            `kiwi_index:"360"`
	WidgetMetadata                        *WidgetMetadata                 `kiwi_index:"262"`
	WidgetEvents                          []WidgetEvent                   `kiwi_index:"263"`
	WidgetPropertyMenuItems               []*WidgetPropertyMenuItem       `kiwi_index:"265"`
	WidgetInputTextNodeType               WidgetInputTextNodeType         `kiwi_index:"401"`
	TableRowPositions                     *TableRowColumnPositionMap      `kiwi_index:"308"`
	TableColumnPositions                  *TableRowColumnPositionMap      `kiwi_index:"309"`
	TableRowHeights                       *TableRowColumnSizeMap          `kiwi_index:"310"`
	TableColumnWidths                     *TableRowColumnSizeMap          `kiwi_index:"311"`
	InteractiveSlideConfigData            *MultiplayerMap                 `kiwi_index:"371"`
	InteractiveSlideParticipantData       *MultiplayerMap                 `kiwi_index:"372"`
	FlappType                             FlappType                       `kiwi_index:"402"`
	SlideSpeakerNotes                     string                          `kiwi_index:"389"`
	IsSkippedSlide                        bool                            `kiwi_index:"410"`
	ThemeId                               *ThemeID                        `kiwi_index:"379"`
	SlideThemeData                        *SlideThemeData                 `kiwi_index:"381"`
	SlideThemeMap                         *SlideThemeMap                  `kiwi_index:"390"`
	SlideTemplateFileKey                  string                          `kiwi_index:"393"`
	DiagramParentId                       *GUID                           `kiwi_index:"363"`
	LayoutRoot                            *GUID                           `kiwi_index:"362"`
	LayoutPosition                        string                          `kiwi_index:"364"`
	DiagramLayoutRuleType                 DiagramLayoutRuleType           `kiwi_index:"366"`
	DiagramParentIndex                    *DiagramParentIndex             `kiwi_index:"367"`
	DiagramLayoutPaused                   DiagramLayoutPaused             `kiwi_index:"368"`
	IsPageDivider                         bool                            `kiwi_index:"380"`
	InternalEnumForTest                   InternalEnumForTest             `kiwi_index:"251"`
	InternalDataForTest                   *InternalDataForTest            `kiwi_index:"257"`
	Count                                 uint                            `kiwi_index:"10"`
	CountTag                              uint                            `kiwi_index:"62"`
	AutoRename                            bool                            `kiwi_index:"14"`
	AutoRenameTag                         uint                            `kiwi_index:"66"`
	BackgroundEnabled                     bool                            `kiwi_index:"15"`
	BackgroundEnabledTag                  uint                            `kiwi_index:"67"`
	ExportContentsOnly                    bool                            `kiwi_index:"17"`
	ExportContentsOnlyTag                 uint                            `kiwi_index:"69"`
	StarInnerScale                        float64                         `kiwi_index:"24"`
	StarInnerScaleTag                     uint                            `kiwi_index:"76"`
	MiterLimit                            float64                         `kiwi_index:"25"`
	MiterLimitTag                         uint                            `kiwi_index:"77"`
	TextTracking                          float64                         `kiwi_index:"27"`
	TextTrackingTag                       uint                            `kiwi_index:"79"`
	BooleanOperation                      BooleanOperation                `kiwi_index:"36"`
	BooleanOperationTag                   uint                            `kiwi_index:"88"`
	VerticalConstraint                    ConstraintType                  `kiwi_index:"37"`
	VerticalConstraintTag                 uint                            `kiwi_index:"89"`
	HandleMirroring                       VectorMirror                    `kiwi_index:"44"`
	HandleMirroringTag                    uint                            `kiwi_index:"96"`
	ExportSettings                        []*ExportSettings               `kiwi_index:"45"`
	ExportSettingsTag                     uint                            `kiwi_index:"97"`
	TextAutoResize                        TextAutoResize                  `kiwi_index:"46"`
	TextAutoResizeTag                     uint                            `kiwi_index:"98"`
	LayoutGrids                           []*LayoutGrid                   `kiwi_index:"47"`
	LayoutGridsTag                        uint                            `kiwi_index:"99"`
	VectorData                            *VectorData                     `kiwi_index:"48"`
	VectorDataTag                         uint                            `kiwi_index:"100"`
	FrameMaskDisabled                     bool                            `kiwi_index:"115"`
	FrameMaskDisabledTag                  uint                            `kiwi_index:"116"`
	ResizeToFit                           bool                            `kiwi_index:"117"`
	ResizeToFitTag                        uint                            `kiwi_index:"118"`
	ExportBackgroundDisabled              bool                            `kiwi_index:"119"`
	Guides                                []*Guide                        `kiwi_index:"138"`
	InternalOnly                          bool                            `kiwi_index:"142"`
	ScrollDirection                       ScrollDirection                 `kiwi_index:"159"`
	CornerSmoothing                       float64                         `kiwi_index:"160"`
	ScrollOffset                          *Vector                         `kiwi_index:"166"`
	ExportTextAsSvgText                   bool                            `kiwi_index:"175"`
	ScrollContractedState                 ScrollContractedState           `kiwi_index:"178"`
	ContractedSize                        *Vector                         `kiwi_index:"179"`
	FixedChildrenDivider                  string                          `kiwi_index:"180"`
	ScrollBehavior                        ScrollBehavior                  `kiwi_index:"186"`
	ArcData                               *ArcData                        `kiwi_index:"195"`
	DerivedSymbolDataLayoutVersion        int                             `kiwi_index:"196"`
	NavigationType                        NavigationType                  `kiwi_index:"197"`
	OverlayPositionType                   OverlayPositionType             `kiwi_index:"198"`
	OverlayRelativePosition               *Vector                         `kiwi_index:"199"`
	OverlayBackgroundInteraction          OverlayBackgroundInteraction    `kiwi_index:"200"`
	OverlayBackgroundAppearance           *OverlayBackgroundAppearance    `kiwi_index:"201"`
	OverrideKey                           *GUID                           `kiwi_index:"213"`
	ContainerSupportsFillStrokeAndCorners bool                            `kiwi_index:"220"`
	StackCounterSizing                    StackSize                       `kiwi_index:"221"`
	ContainersSupportFillStrokeAndCorners bool                            `kiwi_index:"222"`
	KeyTrigger                            *KeyTrigger                     `kiwi_index:"224"`
	VoiceEventPhrase                      string                          `kiwi_index:"227"`
	AncestorPathBeforeDeletion            []*GUID                         `kiwi_index:"235"`
	SymbolLinks                           []*SymbolLink                   `kiwi_index:"237"`
	TextListData                          *TextListData                   `kiwi_index:"239"`
	DetachOpticalSizeFromFontSize         bool                            `kiwi_index:"261"`
	ListSpacing                           float64                         `kiwi_index:"264"`
	EmbedData                             *EmbedData                      `kiwi_index:"270"`
	RichMediaData                         *RichMediaData                  `kiwi_index:"272"`
	RenderedSyncedState                   *MultiplayerMap                 `kiwi_index:"277"`
	SimplifyInstancePanels                bool                            `kiwi_index:"284"`
	AccessibleHtmlTag                     HTMLTag                         `kiwi_index:"302"`
	AriaRole                              ARIARole                        `kiwi_index:"303"`
	AccessibleLabel                       string                          `kiwi_index:"304"`
	VariableData                          *VariableData                   `kiwi_index:"306"`
	VariableConsumptionMap                *VariableDataMap                `kiwi_index:"307"`
	VariableModeBySetMap                  *VariableModeBySetMap           `kiwi_index:"316"`
	VariableSetModes                      []*VariableSetMode              `kiwi_index:"312"`
	VariableSetId                         *VariableSetID                  `kiwi_index:"313"`
	VariableResolvedType                  VariableResolvedDataType        `kiwi_index:"314"`
	VariableDataValues                    *VariableDataValues             `kiwi_index:"315"`
	VariableTokenName                     string                          `kiwi_index:"350"`
	VariableScopes                        []VariableScope                 `kiwi_index:"353"`
	CodeSyntax                            *CodeSyntaxMap                  `kiwi_index:"358"`
	PasteSource                           *PasteSource                    `kiwi_index:"388"`
	PageType                              EditorType                      `kiwi_index:"397"`
	BackingVariableSetId                  *VariableSetID                  `kiwi_index:"377"`
	BackingVariableId                     *VariableIdOrVariableOverrideId `kiwi_index:"378"`
	IsCollectionExtendable                bool                            `kiwi_index:"385"`
	RootVariableKey                       string                          `kiwi_index:"386"`
	HandoffStatusMap                      *HandoffStatusMap               `kiwi_index:"361"`
	AgendaPositionMap                     *AgendaPositionMap              `kiwi_index:"327"`
	AgendaMetadataMap                     *AgendaMetadataMap              `kiwi_index:"328"`
	MigrationStatus                       *MigrationStatus                `kiwi_index:"329"`
	IsSoftDeleted                         bool                            `kiwi_index:"330"`
	EditInfo                              *EditInfo                       `kiwi_index:"331"`
	ColorProfile                          ColorProfile                    `kiwi_index:"341"`
	DetachedSymbolId                      *SymbolId                       `kiwi_index:"342"`
	ChildReadingDirection                 ChildReadingDirection           `kiwi_index:"346"`
	ReadingIndex                          string                          `kiwi_index:"347"`
	DocumentColorProfile                  DocumentColorProfile            `kiwi_index:"349"`
	DeveloperRelatedLinks                 []*DeveloperRelatedLink         `kiwi_index:"354"`
	SlideActiveThemeLibKey                string                          `kiwi_index:"356"`
	AriaAttributes                        *ARIAAttributesMap              `kiwi_index:"357"`
	EditScopeInfo                         *EditScopeInfo                  `kiwi_index:"365"`
	SemanticWeight                        SemanticWeight                  `kiwi_index:"374"`
	SemanticItalic                        SemanticItalic                  `kiwi_index:"375"`
	IsResponsiveSet                       bool                            `kiwi_index:"387"`
	DefaultResponsiveSetId                *GUID                           `kiwi_index:"398"`
	ResponsiveSetSettings                 *ResponsiveSetSettings          `kiwi_index:"400"`
	AreSlidesManuallyIndented             bool                            `kiwi_index:"403"`
	Behaviors                             *NodeBehaviors                  `kiwi_index:"404"`
	AiEditedNodeChangeFieldNumbers        []uint                          `kiwi_index:"405"`
	AiEditScopeLabel                      string                          `kiwi_index:"408"`
	FirstDraftData                        *FirstDraftData                 `kiwi_index:"407"`
	Children                              []*NodeChange
}

func DecodeNodeChange(b *gokiwi.Buffer) (res *NodeChange, err error) {
	res = &NodeChange{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 53:
			res.GuidTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Phase = NodePhase(v)
		case 54:
			res.PhaseTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.ParentIndex, err = DecodeParentIndex(b)
			if err != nil {
				return nil, err
			}
		case 55:
			res.ParentIndexTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = NodeType(v)
		case 56:
			res.TypeTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 5:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 57:
			res.NameTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 174:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsPublishable = v != 0
		case 318:
			res.Description, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 256:
			res.LibraryMoveInfo, err = DecodeLibraryMoveInfo(b)
			if err != nil {
				return nil, err
			}
		case 281:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*LibraryMoveHistoryItem, size)
				for i := range size {
					v, err := DecodeLibraryMoveHistoryItem(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.LibraryMoveHistory = values
			}
		case 319:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 383:
			res.FileAssetIds, err = DecodeAssetIdMap(b)
			if err != nil {
				return nil, err
			}
		case 49:
			res.StyleId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 101:
			res.StyleIdTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 176:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsSoftDeletedStyle = v != 0
		case 177:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsNonUpdateable = v != 0
		case 157:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsFillStyle = v != 0
		case 161:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsStrokeStyle = v != 0
		case 376:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsOverrideOverTextStyle = v != 0
		case 163:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StyleType = StyleType(v)
		case 191:
			res.StyleDescription, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 171:
			res.Version, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 172:
			res.SharedStyleMasterData, err = DecodeSharedStyleMasterData(b)
			if err != nil {
				return nil, err
			}
		case 173:
			res.SharedStyleReference, err = DecodeSharedStyleReference(b)
			if err != nil {
				return nil, err
			}
		case 399:
			res.UserFacingVersion, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 320:
			res.SortPosition, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 345:
			res.OjansSuperSecretNodeField, err = DecodeSharedStyleMasterData(b)
			if err != nil {
				return nil, err
			}
		case 348:
			res.SevMoonlitLilyData, err = DecodeSharedStyleMasterData(b)
			if err != nil {
				return nil, err
			}
		case 158:
			res.InheritFillStyleId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 162:
			res.InheritStrokeStyleId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 167:
			res.InheritTextStyleId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 168:
			res.InheritExportStyleId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 169:
			res.InheritEffectStyleId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 170:
			res.InheritGridStyleId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 185:
			res.InheritFillStyleIdForStroke, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 332:
			res.StyleIdForFill, err = DecodeStyleId(b)
			if err != nil {
				return nil, err
			}
		case 333:
			res.StyleIdForStrokeFill, err = DecodeStyleId(b)
			if err != nil {
				return nil, err
			}
		case 334:
			res.StyleIdForText, err = DecodeStyleId(b)
			if err != nil {
				return nil, err
			}
		case 335:
			res.StyleIdForEffect, err = DecodeStyleId(b)
			if err != nil {
				return nil, err
			}
		case 336:
			res.StyleIdForGrid, err = DecodeStyleId(b)
			if err != nil {
				return nil, err
			}
		case 193:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Paint, size)
				for i := range size {
					v, err := DecodePaint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.BackgroundPaints = values
			}
		case 194:
			res.InheritFillStyleIdForBackground, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 225:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsStateGroup = v != 0
		case 238:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*StateGroupPropertyValueOrder, size)
				for i := range size {
					v, err := DecodeStateGroupPropertyValueOrder(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StateGroupPropertyValueOrders = values
			}
		case 122:
			res.SharedSymbolReference, err = DecodeSharedSymbolReference(b)
			if err != nil {
				return nil, err
			}
		case 123:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsSymbolPublishable = v != 0
		case 124:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPathMapping, size)
				for i := range size {
					v, err := DecodeGUIDPathMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.SharedSymbolMappings = values
			}
		case 126:
			res.SharedSymbolVersion, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 152:
			res.SharedComponentMasterData, err = DecodeSharedComponentMasterData(b)
			if err != nil {
				return nil, err
			}
		case 144:
			res.SymbolDescription, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 164:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPathMapping, size)
				for i := range size {
					v, err := DecodeGUIDPathMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.UnflatteningMappings = values
			}
		case 228:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPathMapping, size)
				for i := range size {
					v, err := DecodeGUIDPathMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ForceUnflatteningMappings = values
			}
		case 214:
			res.PublishFile, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 395:
			res.SourceLibraryKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 215:
			res.PublishId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 216:
			res.ComponentKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 217:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsC2 = v != 0
		case 218:
			res.PublishedVersion, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 252:
			res.OriginComponentKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 266:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ComponentPropDef, size)
				for i := range size {
					v, err := DecodeComponentPropDef(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ComponentPropDefs = values
			}
		case 267:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ComponentPropRef, size)
				for i := range size {
					v, err := DecodeComponentPropRef(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ComponentPropRefs = values
			}
		case 113:
			res.SymbolData, err = DecodeSymbolData(b)
			if err != nil {
				return nil, err
			}
		case 114:
			res.SymbolDataTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 125:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DerivedSymbolData = values
			}
		case 394:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.NestedInstanceResizeEnabled = v != 0
		case 143:
			res.OverriddenSymbolId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 268:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ComponentPropAssignment, size)
				for i := range size {
					v, err := DecodeComponentPropAssignment(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ComponentPropAssignments = values
			}
		case 305:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.PropsAreBubbled = v != 0
		case 248:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*InstanceOverrideStash, size)
				for i := range size {
					v, err := DecodeInstanceOverrideStash(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.OverrideStash = values
			}
		case 250:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*InstanceOverrideStashV2, size)
				for i := range size {
					v, err := DecodeInstanceOverrideStashV2(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.OverrideStashV2 = values
			}
		case 111:
			res.GuidPath, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 112:
			res.GuidPathTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 321:
			res.OverrideLevel, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 382:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ModuleType = ModuleType(v)
		case 21:
			res.FontSize, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 73:
			res.FontSizeTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 22:
			res.ParagraphIndent, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 74:
			res.ParagraphIndentTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 23:
			res.ParagraphSpacing, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 75:
			res.ParagraphSpacingTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 32:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TextAlignHorizontal = TextAlignHorizontal(v)
		case 84:
			res.TextAlignHorizontalTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 33:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TextAlignVertical = TextAlignVertical(v)
		case 85:
			res.TextAlignVerticalTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 34:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TextCase = TextCase(v)
		case 86:
			res.TextCaseTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 35:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TextDecoration = TextDecoration(v)
		case 87:
			res.TextDecorationTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 40:
			res.LineHeight, err = DecodeNumber(b)
			if err != nil {
				return nil, err
			}
		case 92:
			res.LineHeightTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 41:
			res.FontName, err = DecodeFontName(b)
			if err != nil {
				return nil, err
			}
		case 93:
			res.FontNameTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 42:
			res.TextData, err = DecodeTextData(b)
			if err != nil {
				return nil, err
			}
		case 94:
			res.TextDataTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 359:
			res.DerivedTextData, err = DecodeDerivedTextData(b)
			if err != nil {
				return nil, err
			}
		case 127:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FontVariantCommonLigatures = v != 0
		case 128:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FontVariantContextualLigatures = v != 0
		case 129:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FontVariantDiscretionaryLigatures = v != 0
		case 130:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FontVariantHistoricalLigatures = v != 0
		case 131:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FontVariantOrdinal = v != 0
		case 132:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FontVariantSlashedZero = v != 0
		case 133:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FontVariantNumericFigure = FontVariantNumericFigure(v)
		case 134:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FontVariantNumericSpacing = FontVariantNumericSpacing(v)
		case 135:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FontVariantNumericFraction = FontVariantNumericFraction(v)
		case 136:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FontVariantCaps = FontVariantCaps(v)
		case 137:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FontVariantPosition = FontVariantPosition(v)
		case 165:
			res.LetterSpacing, err = DecodeNumber(b)
			if err != nil {
				return nil, err
			}
		case 202:
			res.FontVersion, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 322:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.LeadingTrim = LeadingTrim(v)
		case 337:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.HangingPunctuation = v != 0
		case 339:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.HangingList = v != 0
		case 351:
			res.MaxLines, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 352:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.SectionStatus = SectionStatus(v)
		case 355:
			res.SectionStatusInfo, err = DecodeSectionStatusInfo(b)
			if err != nil {
				return nil, err
			}
		case 203:
			res.TextUserLayoutVersion, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 396:
			res.TextExplicitLayoutVersion, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 205:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]OpenTypeFeature, size)
				for i := range size {
					v, err := b.ReadVarUint()
					if err != nil {
						return nil, err
					}
					values[i] = OpenTypeFeature(v)
				}
				res.ToggledOnOtFeatures = values
			}
		case 206:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]OpenTypeFeature, size)
				for i := range size {
					v, err := b.ReadVarUint()
					if err != nil {
						return nil, err
					}
					values[i] = OpenTypeFeature(v)
				}
				res.ToggledOffOtFeatures = values
			}
		case 223:
			res.Hyperlink, err = DecodeHyperlink(b)
			if err != nil {
				return nil, err
			}
		case 340:
			res.Mention, err = DecodeMention(b)
			if err != nil {
				return nil, err
			}
		case 260:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*FontVariation, size)
				for i := range size {
					v, err := DecodeFontVariation(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FontVariations = values
			}
		case 279:
			res.TextBidiVersion, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 280:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TextTruncation = TextTruncation(v)
		case 292:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.HasHadRtlText = v != 0
		case 391:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.EmojiImageSet = EmojiImageSet(v)
		case 392:
			res.SlideThumbnailHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Visible = v != 0
		case 58:
			res.VisibleTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 7:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Locked = v != 0
		case 59:
			res.LockedTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 8:
			res.Opacity, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 60:
			res.OpacityTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 9:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.BlendMode = BlendMode(v)
		case 61:
			res.BlendModeTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 11:
			res.Size, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 63:
			res.SizeTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 12:
			res.Transform, err = DecodeMatrix(b)
			if err != nil {
				return nil, err
			}
		case 64:
			res.TransformTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 13:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]float64, size)
				for i := range size {
					values[i], err = b.ReadVarFloat()
					if err != nil {
						return nil, err
					}
				}
				res.DashPattern = values
			}
		case 65:
			res.DashPatternTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 16:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Mask = v != 0
		case 68:
			res.MaskTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 18:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.MaskIsOutline = v != 0
		case 70:
			res.MaskIsOutlineTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 317:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.MaskType = MaskType(v)
		case 19:
			res.BackgroundOpacity, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 71:
			res.BackgroundOpacityTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 20:
			res.CornerRadius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 72:
			res.CornerRadiusTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 26:
			res.StrokeWeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 78:
			res.StrokeWeightTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 29:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StrokeAlign = StrokeAlign(v)
		case 81:
			res.StrokeAlignTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 30:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StrokeCap = StrokeCap(v)
		case 82:
			res.StrokeCapTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 31:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StrokeJoin = StrokeJoin(v)
		case 83:
			res.StrokeJoinTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 38:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Paint, size)
				for i := range size {
					v, err := DecodePaint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FillPaints = values
			}
		case 90:
			res.FillPaintsTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 39:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Paint, size)
				for i := range size {
					v, err := DecodePaint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StrokePaints = values
			}
		case 91:
			res.StrokePaintsTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 43:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Effect, size)
				for i := range size {
					v, err := DecodeEffect(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Effects = values
			}
		case 95:
			res.EffectsTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 50:
			res.BackgroundColor, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 102:
			res.BackgroundColorTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 51:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Path, size)
				for i := range size {
					v, err := DecodePath(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FillGeometry = values
			}
		case 103:
			res.FillGeometryTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 52:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Path, size)
				for i := range size {
					v, err := DecodePath(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StrokeGeometry = values
			}
		case 104:
			res.StrokeGeometryTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 411:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Paint, size)
				for i := range size {
					v, err := DecodePaint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.TextDecorationFillPaints = values
			}
		case 145:
			res.RectangleTopLeftCornerRadius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 146:
			res.RectangleTopRightCornerRadius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 147:
			res.RectangleBottomLeftCornerRadius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 148:
			res.RectangleBottomRightCornerRadius, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 149:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.RectangleCornerRadiiIndependent = v != 0
		case 150:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.RectangleCornerToolIndependent = v != 0
		case 151:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ProportionsConstrained = v != 0
		case 258:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.UseAbsoluteBounds = v != 0
		case 287:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BorderTopHidden = v != 0
		case 288:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BorderBottomHidden = v != 0
		case 289:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BorderLeftHidden = v != 0
		case 290:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BorderRightHidden = v != 0
		case 294:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BordersTakeSpace = v != 0
		case 295:
			res.BorderTopWeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 296:
			res.BorderBottomWeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 297:
			res.BorderLeftWeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 298:
			res.BorderRightWeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 299:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BorderStrokeWeightsIndependent = v != 0
		case 28:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.HorizontalConstraint = ConstraintType(v)
		case 80:
			res.HorizontalConstraintTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 105:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackMode = StackMode(v)
		case 106:
			res.StackModeTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 107:
			res.StackSpacing, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 108:
			res.StackSpacingTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 109:
			res.StackPadding, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 110:
			res.StackPaddingTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 120:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackCounterAlign = StackCounterAlign(v)
		case 121:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackJustify = StackJustify(v)
		case 208:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackAlign = StackAlign(v)
		case 209:
			res.StackHorizontalPadding, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 210:
			res.StackVerticalPadding, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 211:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackWidth = StackSize(v)
		case 212:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackHeight = StackSize(v)
		case 229:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackPrimarySizing = StackSize(v)
		case 230:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackPrimaryAlignItems = StackJustify(v)
		case 231:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackCounterAlignItems = StackAlign(v)
		case 232:
			res.StackChildPrimaryGrow, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 233:
			res.StackPaddingRight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 234:
			res.StackPaddingBottom, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 236:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackChildAlignSelf = StackCounterAlign(v)
		case 269:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackPositioning = StackPositioning(v)
		case 271:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.StackReverseZIndex = v != 0
		case 323:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackWrap = StackWrap(v)
		case 324:
			res.StackCounterSpacing, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 325:
			res.MinSize, err = DecodeOptionalVector(b)
			if err != nil {
				return nil, err
			}
		case 326:
			res.MaxSize, err = DecodeOptionalVector(b)
			if err != nil {
				return nil, err
			}
		case 343:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackCounterAlignContent = StackCounterAlignContent(v)
		case 406:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]int, size)
				for i := range size {
					values[i], err = b.ReadVarInt()
					if err != nil {
						return nil, err
					}
				}
				res.SortedMovingChildIndices = values
			}
		case 344:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsSnakeGameBoard = v != 0
		case 139:
			res.TransitionNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 140:
			res.PrototypeStartNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 141:
			res.PrototypeBackgroundColor, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 153:
			res.TransitionInfo, err = DecodeTransitionInfo(b)
			if err != nil {
				return nil, err
			}
		case 154:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TransitionType = TransitionType(v)
		case 155:
			res.TransitionDuration, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 156:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.EasingType = EasingType(v)
		case 181:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionPreserveScroll = v != 0
		case 182:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ConnectionType = ConnectionType(v)
		case 183:
			res.ConnectionUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 184:
			res.PrototypeDevice, err = DecodePrototypeDevice(b)
			if err != nil {
				return nil, err
			}
		case 187:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.InteractionType = InteractionType(v)
		case 188:
			res.TransitionTimeout, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 189:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.InteractionMaintained = v != 0
		case 190:
			res.InteractionDuration, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 192:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.DestinationIsOverlay = v != 0
		case 207:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionShouldSmartAnimate = v != 0
		case 226:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PrototypeInteraction, size)
				for i := range size {
					v, err := DecodePrototypeInteraction(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PrototypeInteractions = values
			}
		case 249:
			res.PrototypeStartingPoint, err = DecodePrototypeStartingPoint(b)
			if err != nil {
				return nil, err
			}
		case 204:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PluginData, size)
				for i := range size {
					v, err := DecodePluginData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PluginData = values
			}
		case 219:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PluginRelaunchData, size)
				for i := range size {
					v, err := DecodePluginRelaunchData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PluginRelaunchData = values
			}
		case 242:
			res.ConnectorStart, err = DecodeConnectorEndpoint(b)
			if err != nil {
				return nil, err
			}
		case 243:
			res.ConnectorEnd, err = DecodeConnectorEndpoint(b)
			if err != nil {
				return nil, err
			}
		case 244:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ConnectorLineStyle = ConnectorLineStyle(v)
		case 245:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ConnectorStartCap = StrokeCap(v)
		case 246:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ConnectorEndCap = StrokeCap(v)
		case 253:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ConnectorControlPoint, size)
				for i := range size {
					v, err := DecodeConnectorControlPoint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ConnectorControlPoints = values
			}
		case 255:
			res.ConnectorTextMidpoint, err = DecodeConnectorTextMidpoint(b)
			if err != nil {
				return nil, err
			}
		case 373:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ConnectorType = ConnectorType(v)
		case 369:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Annotation, size)
				for i := range size {
					v, err := DecodeAnnotation(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Annotations = values
			}
		case 384:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*AnnotationMeasurement, size)
				for i := range size {
					v, err := DecodeAnnotationMeasurement(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Measurements = values
			}
		case 241:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ShapeWithTextType = ShapeWithTextType(v)
		case 247:
			res.ShapeUserHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 254:
			res.DerivedImmutableFrameData, err = DecodeDerivedImmutableFrameData(b)
			if err != nil {
				return nil, err
			}
		case 338:
			res.DerivedImmutableFrameDataVersion, err = DecodeMultiplayerFieldVersion(b)
			if err != nil {
				return nil, err
			}
		case 240:
			res.NodeGenerationData, err = DecodeNodeGenerationData(b)
			if err != nil {
				return nil, err
			}
		case 259:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.CodeBlockLanguage = CodeBlockLanguage(v)
		case 278:
			res.LinkPreviewData, err = DecodeLinkPreviewData(b)
			if err != nil {
				return nil, err
			}
		case 282:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ShapeTruncates = v != 0
		case 283:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.SectionContentsHidden = v != 0
		case 300:
			res.VideoPlayback, err = DecodeVideoPlayback(b)
			if err != nil {
				return nil, err
			}
		case 301:
			res.StampData, err = DecodeStampData(b)
			if err != nil {
				return nil, err
			}
		case 370:
			res.SectionPresetInfo, err = DecodeSectionPresetInfo(b)
			if err != nil {
				return nil, err
			}
		case 409:
			res.PlatformShapeDefinition, err = DecodePlatformShapeDefinition(b)
			if err != nil {
				return nil, err
			}
		case 273:
			res.WidgetSyncedState, err = DecodeMultiplayerMap(b)
			if err != nil {
				return nil, err
			}
		case 274:
			res.WidgetSyncCursor, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 275:
			res.WidgetDerivedSubtreeCursor, err = DecodeWidgetDerivedSubtreeCursor(b)
			if err != nil {
				return nil, err
			}
		case 276:
			res.WidgetCachedAncestor, err = DecodeWidgetPointer(b)
			if err != nil {
				return nil, err
			}
		case 285:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.WidgetInputBehavior = WidgetInputBehavior(v)
		case 286:
			res.WidgetTooltip, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 291:
			res.WidgetHoverStyle, err = DecodeWidgetHoverStyle(b)
			if err != nil {
				return nil, err
			}
		case 293:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsWidgetStickable = v != 0
		case 360:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ShouldHideCursorsOnWidgetHover = v != 0
		case 262:
			res.WidgetMetadata, err = DecodeWidgetMetadata(b)
			if err != nil {
				return nil, err
			}
		case 263:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]WidgetEvent, size)
				for i := range size {
					v, err := b.ReadVarUint()
					if err != nil {
						return nil, err
					}
					values[i] = WidgetEvent(v)
				}
				res.WidgetEvents = values
			}
		case 265:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*WidgetPropertyMenuItem, size)
				for i := range size {
					v, err := DecodeWidgetPropertyMenuItem(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.WidgetPropertyMenuItems = values
			}
		case 401:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.WidgetInputTextNodeType = WidgetInputTextNodeType(v)
		case 308:
			res.TableRowPositions, err = DecodeTableRowColumnPositionMap(b)
			if err != nil {
				return nil, err
			}
		case 309:
			res.TableColumnPositions, err = DecodeTableRowColumnPositionMap(b)
			if err != nil {
				return nil, err
			}
		case 310:
			res.TableRowHeights, err = DecodeTableRowColumnSizeMap(b)
			if err != nil {
				return nil, err
			}
		case 311:
			res.TableColumnWidths, err = DecodeTableRowColumnSizeMap(b)
			if err != nil {
				return nil, err
			}
		case 371:
			res.InteractiveSlideConfigData, err = DecodeMultiplayerMap(b)
			if err != nil {
				return nil, err
			}
		case 372:
			res.InteractiveSlideParticipantData, err = DecodeMultiplayerMap(b)
			if err != nil {
				return nil, err
			}
		case 402:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.FlappType = FlappType(v)
		case 389:
			res.SlideSpeakerNotes, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 410:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsSkippedSlide = v != 0
		case 379:
			res.ThemeId, err = DecodeThemeID(b)
			if err != nil {
				return nil, err
			}
		case 381:
			res.SlideThemeData, err = DecodeSlideThemeData(b)
			if err != nil {
				return nil, err
			}
		case 390:
			res.SlideThemeMap, err = DecodeSlideThemeMap(b)
			if err != nil {
				return nil, err
			}
		case 393:
			res.SlideTemplateFileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 363:
			res.DiagramParentId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 362:
			res.LayoutRoot, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 364:
			res.LayoutPosition, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 366:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.DiagramLayoutRuleType = DiagramLayoutRuleType(v)
		case 367:
			res.DiagramParentIndex, err = DecodeDiagramParentIndex(b)
			if err != nil {
				return nil, err
			}
		case 368:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.DiagramLayoutPaused = DiagramLayoutPaused(v)
		case 380:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsPageDivider = v != 0
		case 251:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.InternalEnumForTest = InternalEnumForTest(v)
		case 257:
			res.InternalDataForTest, err = DecodeInternalDataForTest(b)
			if err != nil {
				return nil, err
			}
		case 10:
			res.Count, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 62:
			res.CountTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 14:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.AutoRename = v != 0
		case 66:
			res.AutoRenameTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 15:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BackgroundEnabled = v != 0
		case 67:
			res.BackgroundEnabledTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 17:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ExportContentsOnly = v != 0
		case 69:
			res.ExportContentsOnlyTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 24:
			res.StarInnerScale, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 76:
			res.StarInnerScaleTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 25:
			res.MiterLimit, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 77:
			res.MiterLimitTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 27:
			res.TextTracking, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 79:
			res.TextTrackingTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 36:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.BooleanOperation = BooleanOperation(v)
		case 88:
			res.BooleanOperationTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 37:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.VerticalConstraint = ConstraintType(v)
		case 89:
			res.VerticalConstraintTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 44:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.HandleMirroring = VectorMirror(v)
		case 96:
			res.HandleMirroringTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 45:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ExportSettings, size)
				for i := range size {
					v, err := DecodeExportSettings(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ExportSettings = values
			}
		case 97:
			res.ExportSettingsTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 46:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TextAutoResize = TextAutoResize(v)
		case 98:
			res.TextAutoResizeTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 47:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*LayoutGrid, size)
				for i := range size {
					v, err := DecodeLayoutGrid(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.LayoutGrids = values
			}
		case 99:
			res.LayoutGridsTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 48:
			res.VectorData, err = DecodeVectorData(b)
			if err != nil {
				return nil, err
			}
		case 100:
			res.VectorDataTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 115:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FrameMaskDisabled = v != 0
		case 116:
			res.FrameMaskDisabledTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 117:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ResizeToFit = v != 0
		case 118:
			res.ResizeToFitTag, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 119:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ExportBackgroundDisabled = v != 0
		case 138:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Guide, size)
				for i := range size {
					v, err := DecodeGuide(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Guides = values
			}
		case 142:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.InternalOnly = v != 0
		case 159:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ScrollDirection = ScrollDirection(v)
		case 160:
			res.CornerSmoothing, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 166:
			res.ScrollOffset, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 175:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ExportTextAsSvgText = v != 0
		case 178:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ScrollContractedState = ScrollContractedState(v)
		case 179:
			res.ContractedSize, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 180:
			res.FixedChildrenDivider, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 186:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ScrollBehavior = ScrollBehavior(v)
		case 195:
			res.ArcData, err = DecodeArcData(b)
			if err != nil {
				return nil, err
			}
		case 196:
			res.DerivedSymbolDataLayoutVersion, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 197:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.NavigationType = NavigationType(v)
		case 198:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.OverlayPositionType = OverlayPositionType(v)
		case 199:
			res.OverlayRelativePosition, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 200:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.OverlayBackgroundInteraction = OverlayBackgroundInteraction(v)
		case 201:
			res.OverlayBackgroundAppearance, err = DecodeOverlayBackgroundAppearance(b)
			if err != nil {
				return nil, err
			}
		case 213:
			res.OverrideKey, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 220:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ContainerSupportsFillStrokeAndCorners = v != 0
		case 221:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StackCounterSizing = StackSize(v)
		case 222:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.ContainersSupportFillStrokeAndCorners = v != 0
		case 224:
			res.KeyTrigger, err = DecodeKeyTrigger(b)
			if err != nil {
				return nil, err
			}
		case 227:
			res.VoiceEventPhrase, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 235:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.AncestorPathBeforeDeletion = values
			}
		case 237:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*SymbolLink, size)
				for i := range size {
					v, err := DecodeSymbolLink(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.SymbolLinks = values
			}
		case 239:
			res.TextListData, err = DecodeTextListData(b)
			if err != nil {
				return nil, err
			}
		case 261:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.DetachOpticalSizeFromFontSize = v != 0
		case 264:
			res.ListSpacing, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 270:
			res.EmbedData, err = DecodeEmbedData(b)
			if err != nil {
				return nil, err
			}
		case 272:
			res.RichMediaData, err = DecodeRichMediaData(b)
			if err != nil {
				return nil, err
			}
		case 277:
			res.RenderedSyncedState, err = DecodeMultiplayerMap(b)
			if err != nil {
				return nil, err
			}
		case 284:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.SimplifyInstancePanels = v != 0
		case 302:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.AccessibleHtmlTag = HTMLTag(v)
		case 303:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.AriaRole = ARIARole(v)
		case 304:
			res.AccessibleLabel, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 306:
			res.VariableData, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 307:
			res.VariableConsumptionMap, err = DecodeVariableDataMap(b)
			if err != nil {
				return nil, err
			}
		case 316:
			res.VariableModeBySetMap, err = DecodeVariableModeBySetMap(b)
			if err != nil {
				return nil, err
			}
		case 312:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableSetMode, size)
				for i := range size {
					v, err := DecodeVariableSetMode(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.VariableSetModes = values
			}
		case 313:
			res.VariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		case 314:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.VariableResolvedType = VariableResolvedDataType(v)
		case 315:
			res.VariableDataValues, err = DecodeVariableDataValues(b)
			if err != nil {
				return nil, err
			}
		case 350:
			res.VariableTokenName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 353:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]VariableScope, size)
				for i := range size {
					v, err := b.ReadVarUint()
					if err != nil {
						return nil, err
					}
					values[i] = VariableScope(v)
				}
				res.VariableScopes = values
			}
		case 358:
			res.CodeSyntax, err = DecodeCodeSyntaxMap(b)
			if err != nil {
				return nil, err
			}
		case 388:
			res.PasteSource, err = DecodePasteSource(b)
			if err != nil {
				return nil, err
			}
		case 397:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.PageType = EditorType(v)
		case 377:
			res.BackingVariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		case 378:
			res.BackingVariableId, err = DecodeVariableIdOrVariableOverrideId(b)
			if err != nil {
				return nil, err
			}
		case 385:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsCollectionExtendable = v != 0
		case 386:
			res.RootVariableKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 361:
			res.HandoffStatusMap, err = DecodeHandoffStatusMap(b)
			if err != nil {
				return nil, err
			}
		case 327:
			res.AgendaPositionMap, err = DecodeAgendaPositionMap(b)
			if err != nil {
				return nil, err
			}
		case 328:
			res.AgendaMetadataMap, err = DecodeAgendaMetadataMap(b)
			if err != nil {
				return nil, err
			}
		case 329:
			res.MigrationStatus, err = DecodeMigrationStatus(b)
			if err != nil {
				return nil, err
			}
		case 330:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsSoftDeleted = v != 0
		case 331:
			res.EditInfo, err = DecodeEditInfo(b)
			if err != nil {
				return nil, err
			}
		case 341:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ColorProfile = ColorProfile(v)
		case 342:
			res.DetachedSymbolId, err = DecodeSymbolId(b)
			if err != nil {
				return nil, err
			}
		case 346:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ChildReadingDirection = ChildReadingDirection(v)
		case 347:
			res.ReadingIndex, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 349:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.DocumentColorProfile = DocumentColorProfile(v)
		case 354:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*DeveloperRelatedLink, size)
				for i := range size {
					v, err := DecodeDeveloperRelatedLink(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DeveloperRelatedLinks = values
			}
		case 356:
			res.SlideActiveThemeLibKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 357:
			res.AriaAttributes, err = DecodeARIAAttributesMap(b)
			if err != nil {
				return nil, err
			}
		case 365:
			res.EditScopeInfo, err = DecodeEditScopeInfo(b)
			if err != nil {
				return nil, err
			}
		case 374:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.SemanticWeight = SemanticWeight(v)
		case 375:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.SemanticItalic = SemanticItalic(v)
		case 387:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsResponsiveSet = v != 0
		case 398:
			res.DefaultResponsiveSetId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 400:
			res.ResponsiveSetSettings, err = DecodeResponsiveSetSettings(b)
			if err != nil {
				return nil, err
			}
		case 403:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.AreSlidesManuallyIndented = v != 0
		case 404:
			res.Behaviors, err = DecodeNodeBehaviors(b)
			if err != nil {
				return nil, err
			}
		case 405:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.AiEditedNodeChangeFieldNumbers = values
			}
		case 408:
			res.AiEditScopeLabel, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 407:
			res.FirstDraftData, err = DecodeFirstDraftData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ResponsiveSetSettings struct {
	Title                 string                `kiwi_index:"1"`
	Description           string                `kiwi_index:"2"`
	ScalingMode           ResponsiveScalingMode `kiwi_index:"3"`
	ScalingMinFontSize    float64               `kiwi_index:"4"`
	ScalingMaxFontSize    float64               `kiwi_index:"5"`
	ScalingMinLayoutWidth float64               `kiwi_index:"6"`
	ScalingMaxLayoutWidth float64               `kiwi_index:"7"`
}

func DecodeResponsiveSetSettings(b *gokiwi.Buffer) (res *ResponsiveSetSettings, err error) {
	res = &ResponsiveSetSettings{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Title, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Description, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ScalingMode = ResponsiveScalingMode(v)
		case 4:
			res.ScalingMinFontSize, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 5:
			res.ScalingMaxFontSize, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 6:
			res.ScalingMinLayoutWidth, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.ScalingMaxLayoutWidth, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ResponsiveScalingMode int

const (
	ResponsiveScalingModeReflow ResponsiveScalingMode = 0
	ResponsiveScalingModeScale  ResponsiveScalingMode = 1
)

type VideoPlayback struct {
	Autoplay  bool `kiwi_index:"1"`
	MediaLoop bool `kiwi_index:"2"`
	Muted     bool `kiwi_index:"3"`
}

func DecodeVideoPlayback(b *gokiwi.Buffer) (res *VideoPlayback, err error) {
	res = &VideoPlayback{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Autoplay = v != 0
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.MediaLoop = v != 0
		case 3:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Muted = v != 0
		}
	}
	return
}

type MediaAction int

const (
	MediaActionPlay             MediaAction = 0
	MediaActionPause            MediaAction = 1
	MediaActionTogglePlayPause  MediaAction = 2
	MediaActionMute             MediaAction = 3
	MediaActionUnmute           MediaAction = 4
	MediaActionToggleMuteUnmute MediaAction = 5
	MediaActionSkipForward      MediaAction = 6
	MediaActionSkipBackward     MediaAction = 7
	MediaActionSkipTo           MediaAction = 8
)

type WidgetHoverStyle struct {
	FillPaints         []*Paint `kiwi_index:"1"`
	StrokePaints       []*Paint `kiwi_index:"2"`
	Opacity            float64  `kiwi_index:"3"`
	AreFillPaintsSet   bool     `kiwi_index:"4"`
	AreStrokePaintsSet bool     `kiwi_index:"5"`
	IsOpacitySet       bool     `kiwi_index:"6"`
}

func DecodeWidgetHoverStyle(b *gokiwi.Buffer) (res *WidgetHoverStyle, err error) {
	res = &WidgetHoverStyle{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Paint, size)
				for i := range size {
					v, err := DecodePaint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.FillPaints = values
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Paint, size)
				for i := range size {
					v, err := DecodePaint(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StrokePaints = values
			}
		case 3:
			res.Opacity, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.AreFillPaintsSet = v != 0
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.AreStrokePaintsSet = v != 0
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsOpacitySet = v != 0
		}
	}
	return
}

type WidgetDerivedSubtreeCursor struct {
	SessionId uint `kiwi_index:"1"`
	Counter   uint `kiwi_index:"2"`
}

func DecodeWidgetDerivedSubtreeCursor(b *gokiwi.Buffer) (res *WidgetDerivedSubtreeCursor, err error) {
	res = &WidgetDerivedSubtreeCursor{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Counter, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type MultiplayerMap struct {
	Entries []*MultiplayerMapEntry `kiwi_index:"1"`
}

func DecodeMultiplayerMap(b *gokiwi.Buffer) (res *MultiplayerMap, err error) {
	res = &MultiplayerMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*MultiplayerMapEntry, size)
				for i := range size {
					v, err := DecodeMultiplayerMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type MultiplayerMapEntry struct {
	Key   string `kiwi_index:"1"`
	Value string `kiwi_index:"2"`
}

func DecodeMultiplayerMapEntry(b *gokiwi.Buffer) (res *MultiplayerMapEntry, err error) {
	res = &MultiplayerMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Value, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableDataMap struct {
	Entries []*VariableDataMapEntry `kiwi_index:"1"`
}

func DecodeVariableDataMap(b *gokiwi.Buffer) (res *VariableDataMap, err error) {
	res = &VariableDataMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableDataMapEntry, size)
				for i := range size {
					v, err := DecodeVariableDataMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type VariableDataMapEntry struct {
	NodeField     uint          `kiwi_index:"1"`
	VariableData  *VariableData `kiwi_index:"2"`
	VariableField VariableField `kiwi_index:"3"`
}

func DecodeVariableDataMapEntry(b *gokiwi.Buffer) (res *VariableDataMapEntry, err error) {
	res = &VariableDataMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeField, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.VariableData, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.VariableField = VariableField(v)
		}
	}
	return
}

type VariableField int

const (
	VariableFieldMissing                          VariableField = 0
	VariableFieldCornerRadius                     VariableField = 1
	VariableFieldParagraphSpacing                 VariableField = 2
	VariableFieldParagraphIndent                  VariableField = 3
	VariableFieldStrokeWeight                     VariableField = 4
	VariableFieldStackSpacing                     VariableField = 5
	VariableFieldStackPaddingLeft                 VariableField = 6
	VariableFieldStackPaddingTop                  VariableField = 7
	VariableFieldStackPaddingRight                VariableField = 8
	VariableFieldStackPaddingBottom               VariableField = 9
	VariableFieldVisible                          VariableField = 10
	VariableFieldTextData                         VariableField = 11
	VariableFieldWidth                            VariableField = 12
	VariableFieldHeight                           VariableField = 13
	VariableFieldRectangleTopLeftCornerRadius     VariableField = 14
	VariableFieldRectangleTopRightCornerRadius    VariableField = 15
	VariableFieldRectangleBottomLeftCornerRadius  VariableField = 16
	VariableFieldRectangleBottomRightCornerRadius VariableField = 17
	VariableFieldBorderTopWeight                  VariableField = 18
	VariableFieldBorderBottomWeight               VariableField = 19
	VariableFieldBorderLeftWeight                 VariableField = 20
	VariableFieldBorderRightWeight                VariableField = 21
	VariableFieldVariantProperties                VariableField = 22
	VariableFieldStackCounterSpacing              VariableField = 23
	VariableFieldMinWidth                         VariableField = 24
	VariableFieldMaxWidth                         VariableField = 25
	VariableFieldMinHeight                        VariableField = 26
	VariableFieldMaxHeight                        VariableField = 27
	VariableFieldFontFamily                       VariableField = 28
	VariableFieldFontStyle                        VariableField = 29
	VariableFieldFontVariations                   VariableField = 30
	VariableFieldOpacity                          VariableField = 31
	VariableFieldFontSize                         VariableField = 32
	VariableFieldLetterSpacing                    VariableField = 34
	VariableFieldLineHeight                       VariableField = 36
)

type VariableModeBySetMap struct {
	Entries []*VariableModeBySetMapEntry `kiwi_index:"1"`
}

func DecodeVariableModeBySetMap(b *gokiwi.Buffer) (res *VariableModeBySetMap, err error) {
	res = &VariableModeBySetMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableModeBySetMapEntry, size)
				for i := range size {
					v, err := DecodeVariableModeBySetMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type VariableModeBySetMapEntry struct {
	VariableSetId  *VariableSetID `kiwi_index:"1"`
	VariableModeId *GUID          `kiwi_index:"2"`
}

func DecodeVariableModeBySetMapEntry(b *gokiwi.Buffer) (res *VariableModeBySetMapEntry, err error) {
	res = &VariableModeBySetMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.VariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.VariableModeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type CodeSyntaxMap struct {
	Entries []*CodeSyntaxMapEntry `kiwi_index:"1"`
}

func DecodeCodeSyntaxMap(b *gokiwi.Buffer) (res *CodeSyntaxMap, err error) {
	res = &CodeSyntaxMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*CodeSyntaxMapEntry, size)
				for i := range size {
					v, err := DecodeCodeSyntaxMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type CodeSyntaxMapEntry struct {
	Platform CodeSyntaxPlatform `kiwi_index:"1"`
	Value    string             `kiwi_index:"2"`
}

func DecodeCodeSyntaxMapEntry(b *gokiwi.Buffer) (res *CodeSyntaxMapEntry, err error) {
	res = &CodeSyntaxMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Platform = CodeSyntaxPlatform(v)
		case 2:
			res.Value, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TableRowColumnPositionMap struct {
	Entries []*TableRowColumnPositionMapEntry `kiwi_index:"1"`
}

func DecodeTableRowColumnPositionMap(b *gokiwi.Buffer) (res *TableRowColumnPositionMap, err error) {
	res = &TableRowColumnPositionMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TableRowColumnPositionMapEntry, size)
				for i := range size {
					v, err := DecodeTableRowColumnPositionMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type TableRowColumnPositionMapEntry struct {
	Id       *GUID  `kiwi_index:"1"`
	Position string `kiwi_index:"2"`
}

func DecodeTableRowColumnPositionMapEntry(b *gokiwi.Buffer) (res *TableRowColumnPositionMapEntry, err error) {
	res = &TableRowColumnPositionMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Position, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TableRowColumnSizeMap struct {
	Entries []*TableRowColumnSizeMapEntry `kiwi_index:"1"`
}

func DecodeTableRowColumnSizeMap(b *gokiwi.Buffer) (res *TableRowColumnSizeMap, err error) {
	res = &TableRowColumnSizeMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TableRowColumnSizeMapEntry, size)
				for i := range size {
					v, err := DecodeTableRowColumnSizeMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type TableRowColumnSizeMapEntry struct {
	Id   *GUID   `kiwi_index:"1"`
	Size float64 `kiwi_index:"2"`
}

func DecodeTableRowColumnSizeMapEntry(b *gokiwi.Buffer) (res *TableRowColumnSizeMapEntry, err error) {
	res = &TableRowColumnSizeMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Size, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AgendaPositionMap struct {
	Entries []*AgendaPositionMapEntry `kiwi_index:"1"`
}

func DecodeAgendaPositionMap(b *gokiwi.Buffer) (res *AgendaPositionMap, err error) {
	res = &AgendaPositionMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*AgendaPositionMapEntry, size)
				for i := range size {
					v, err := DecodeAgendaPositionMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type AgendaPositionMapEntry struct {
	Id       *GUID  `kiwi_index:"1"`
	Position string `kiwi_index:"2"`
}

func DecodeAgendaPositionMapEntry(b *gokiwi.Buffer) (res *AgendaPositionMapEntry, err error) {
	res = &AgendaPositionMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Position, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AgendaItemType int

const (
	AgendaItemTypeNode  AgendaItemType = 0
	AgendaItemTypeBlock AgendaItemType = 1
)

type AgendaMetadataMap struct {
	Entries []*AgendaMetadataMapEntry `kiwi_index:"1"`
}

func DecodeAgendaMetadataMap(b *gokiwi.Buffer) (res *AgendaMetadataMap, err error) {
	res = &AgendaMetadataMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*AgendaMetadataMapEntry, size)
				for i := range size {
					v, err := DecodeAgendaMetadataMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type AgendaMetadataMapEntry struct {
	Id   *GUID           `kiwi_index:"1"`
	Data *AgendaMetadata `kiwi_index:"2"`
}

func DecodeAgendaMetadataMapEntry(b *gokiwi.Buffer) (res *AgendaMetadataMapEntry, err error) {
	res = &AgendaMetadataMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Data, err = DecodeAgendaMetadata(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AgendaMetadata struct {
	Name         string           `kiwi_index:"1"`
	Type         AgendaItemType   `kiwi_index:"2"`
	TargetNodeId *GUID            `kiwi_index:"3"`
	TimerInfo    *AgendaTimerInfo `kiwi_index:"4"`
	VoteInfo     *AgendaVoteInfo  `kiwi_index:"5"`
	MusicInfo    *AgendaMusicInfo `kiwi_index:"6"`
}

func DecodeAgendaMetadata(b *gokiwi.Buffer) (res *AgendaMetadata, err error) {
	res = &AgendaMetadata{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = AgendaItemType(v)
		case 3:
			res.TargetNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.TimerInfo, err = DecodeAgendaTimerInfo(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.VoteInfo, err = DecodeAgendaVoteInfo(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.MusicInfo, err = DecodeAgendaMusicInfo(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AgendaTimerInfo struct {
	TimerLength uint `kiwi_index:"1"`
}

func DecodeAgendaTimerInfo(b *gokiwi.Buffer) (res *AgendaTimerInfo, err error) {
	res = &AgendaTimerInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.TimerLength, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AgendaVoteInfo struct {
	VoteCount uint `kiwi_index:"1"`
}

func DecodeAgendaVoteInfo(b *gokiwi.Buffer) (res *AgendaVoteInfo, err error) {
	res = &AgendaVoteInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.VoteCount, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AgendaMusicInfo struct {
	SongId      string `kiwi_index:"1"`
	StartTimeMs uint   `kiwi_index:"2"`
}

func DecodeAgendaMusicInfo(b *gokiwi.Buffer) (res *AgendaMusicInfo, err error) {
	res = &AgendaMusicInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SongId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.StartTimeMs, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type DiagramLayoutRuleType int

const (
	DiagramLayoutRuleTypeNone DiagramLayoutRuleType = 0
	DiagramLayoutRuleTypeTree DiagramLayoutRuleType = 1
)

type DiagramParentIndex struct {
	Guid     *GUID
	Position string
}

func DecodeDiagramParentIndex(b *gokiwi.Buffer) (res *DiagramParentIndex, err error) {
	res = &DiagramParentIndex{}
	res.Guid, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.Position, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	return
}

type DiagramLayoutPaused int

const (
	DiagramLayoutPausedNo  DiagramLayoutPaused = 0
	DiagramLayoutPausedYes DiagramLayoutPaused = 1
)

type ComponentPropRef struct {
	NodeField              uint                   `kiwi_index:"1"`
	DefId                  *GUID                  `kiwi_index:"2"`
	ZombieFallbackName     string                 `kiwi_index:"3"`
	ComponentPropNodeField ComponentPropNodeField `kiwi_index:"4"`
	IsDeleted              bool                   `kiwi_index:"5"`
}

func DecodeComponentPropRef(b *gokiwi.Buffer) (res *ComponentPropRef, err error) {
	res = &ComponentPropRef{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeField, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.DefId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.ZombieFallbackName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ComponentPropNodeField = ComponentPropNodeField(v)
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsDeleted = v != 0
		}
	}
	return
}

type ComponentPropNodeField int

const (
	ComponentPropNodeFieldVisible            ComponentPropNodeField = 0
	ComponentPropNodeFieldTextData           ComponentPropNodeField = 1
	ComponentPropNodeFieldOverriddenSymbolId ComponentPropNodeField = 2
	ComponentPropNodeFieldInheritFillStyleId ComponentPropNodeField = 3
)

type ComponentPropAssignment struct {
	DefId                 *GUID               `kiwi_index:"1"`
	Value                 *ComponentPropValue `kiwi_index:"2"`
	VarValue              *VariableData       `kiwi_index:"3"`
	LegacyDerivedTextData *DerivedTextData    `kiwi_index:"4"`
}

func DecodeComponentPropAssignment(b *gokiwi.Buffer) (res *ComponentPropAssignment, err error) {
	res = &ComponentPropAssignment{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.DefId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Value, err = DecodeComponentPropValue(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.VarValue, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.LegacyDerivedTextData, err = DecodeDerivedTextData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ComponentPropDef struct {
	Id              *GUID                         `kiwi_index:"1"`
	Name            string                        `kiwi_index:"2"`
	InitialValue    *ComponentPropValue           `kiwi_index:"3"`
	SortPosition    string                        `kiwi_index:"4"`
	ParentPropDefId *GUID                         `kiwi_index:"5"`
	Type            ComponentPropType             `kiwi_index:"6"`
	IsDeleted       bool                          `kiwi_index:"7"`
	PreferredValues *ComponentPropPreferredValues `kiwi_index:"8"`
	VarValue        *VariableData                 `kiwi_index:"9"`
}

func DecodeComponentPropDef(b *gokiwi.Buffer) (res *ComponentPropDef, err error) {
	res = &ComponentPropDef{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.InitialValue, err = DecodeComponentPropValue(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.SortPosition, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 5:
			res.ParentPropDefId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 6:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = ComponentPropType(v)
		case 7:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsDeleted = v != 0
		case 8:
			res.PreferredValues, err = DecodeComponentPropPreferredValues(b)
			if err != nil {
				return nil, err
			}
		case 9:
			res.VarValue, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ComponentPropValue struct {
	BoolValue bool      `kiwi_index:"1"`
	TextValue *TextData `kiwi_index:"2"`
	GuidValue *GUID     `kiwi_index:"3"`
}

func DecodeComponentPropValue(b *gokiwi.Buffer) (res *ComponentPropValue, err error) {
	res = &ComponentPropValue{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BoolValue = v != 0
		case 2:
			res.TextValue, err = DecodeTextData(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.GuidValue, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ComponentPropType int

const (
	ComponentPropTypeBool         ComponentPropType = 0
	ComponentPropTypeText         ComponentPropType = 1
	ComponentPropTypeColor        ComponentPropType = 2
	ComponentPropTypeInstanceSwap ComponentPropType = 3
)

type ComponentPropPreferredValues struct {
	StringValues       []string                      `kiwi_index:"1"`
	InstanceSwapValues []*InstanceSwapPreferredValue `kiwi_index:"2"`
}

func DecodeComponentPropPreferredValues(b *gokiwi.Buffer) (res *ComponentPropPreferredValues, err error) {
	res = &ComponentPropPreferredValues{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]string, size)
				for i := range size {
					values[i], err = b.ReadString()
					if err != nil {
						return nil, err
					}
				}
				res.StringValues = values
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*InstanceSwapPreferredValue, size)
				for i := range size {
					v, err := DecodeInstanceSwapPreferredValue(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.InstanceSwapValues = values
			}
		}
	}
	return
}

type InstanceSwapPreferredValue struct {
	Type InstanceSwapPreferredValueType `kiwi_index:"1"`
	Key  string                         `kiwi_index:"2"`
}

func DecodeInstanceSwapPreferredValue(b *gokiwi.Buffer) (res *InstanceSwapPreferredValue, err error) {
	res = &InstanceSwapPreferredValue{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = InstanceSwapPreferredValueType(v)
		case 2:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type InstanceSwapPreferredValueType int

const (
	InstanceSwapPreferredValueTypeComponent  InstanceSwapPreferredValueType = 0
	InstanceSwapPreferredValueTypeStateGroup InstanceSwapPreferredValueType = 1
)

type WidgetEvent int

const (
	WidgetEventMouseDown                 WidgetEvent = 0
	WidgetEventClick                     WidgetEvent = 1
	WidgetEventTextEditEnd               WidgetEvent = 2
	WidgetEventAttachedStickablesChanged WidgetEvent = 3
	WidgetEventStuckStatusChanged        WidgetEvent = 4
)

type WidgetInputBehavior int

const (
	WidgetInputBehaviorWrap      WidgetInputBehavior = 0
	WidgetInputBehaviorTruncate  WidgetInputBehavior = 1
	WidgetInputBehaviorMultiline WidgetInputBehavior = 2
)

type WidgetMetadata struct {
	PluginId        string `kiwi_index:"1"`
	PluginVersionId string `kiwi_index:"2"`
	WidgetName      string `kiwi_index:"3"`
}

func DecodeWidgetMetadata(b *gokiwi.Buffer) (res *WidgetMetadata, err error) {
	res = &WidgetMetadata{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.PluginId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.PluginVersionId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.WidgetName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type WidgetPropertyMenuItemType int

const (
	WidgetPropertyMenuItemTypeAction        WidgetPropertyMenuItemType = 0
	WidgetPropertyMenuItemTypeSeparator     WidgetPropertyMenuItemType = 1
	WidgetPropertyMenuItemTypeColor         WidgetPropertyMenuItemType = 2
	WidgetPropertyMenuItemTypeDropdown      WidgetPropertyMenuItemType = 3
	WidgetPropertyMenuItemTypeColorSelector WidgetPropertyMenuItemType = 4
	WidgetPropertyMenuItemTypeToggle        WidgetPropertyMenuItemType = 5
	WidgetPropertyMenuItemTypeLink          WidgetPropertyMenuItemType = 6
)

type WidgetPropertyMenuSelectorOption struct {
	Option  string `kiwi_index:"1"`
	Tooltip string `kiwi_index:"2"`
}

func DecodeWidgetPropertyMenuSelectorOption(b *gokiwi.Buffer) (res *WidgetPropertyMenuSelectorOption, err error) {
	res = &WidgetPropertyMenuSelectorOption{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Option, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Tooltip, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type WidgetInputTextNodeType int

const (
	WidgetInputTextNodeTypeWidgetControlled WidgetInputTextNodeType = 0
	WidgetInputTextNodeTypeRichText         WidgetInputTextNodeType = 1
)

type WidgetPropertyMenuItem struct {
	PropertyName     string                              `kiwi_index:"1"`
	Tooltip          string                              `kiwi_index:"2"`
	ItemType         WidgetPropertyMenuItemType          `kiwi_index:"3"`
	Icon             string                              `kiwi_index:"4"`
	Options          []*WidgetPropertyMenuSelectorOption `kiwi_index:"5"`
	SelectedOption   string                              `kiwi_index:"6"`
	IsToggled        bool                                `kiwi_index:"7"`
	Href             string                              `kiwi_index:"8"`
	AllowCustomColor bool                                `kiwi_index:"9"`
}

func DecodeWidgetPropertyMenuItem(b *gokiwi.Buffer) (res *WidgetPropertyMenuItem, err error) {
	res = &WidgetPropertyMenuItem{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.PropertyName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Tooltip, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ItemType = WidgetPropertyMenuItemType(v)
		case 4:
			res.Icon, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*WidgetPropertyMenuSelectorOption, size)
				for i := range size {
					v, err := DecodeWidgetPropertyMenuSelectorOption(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Options = values
			}
		case 6:
			res.SelectedOption, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 7:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsToggled = v != 0
		case 8:
			res.Href, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 9:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.AllowCustomColor = v != 0
		}
	}
	return
}

type CodeBlockLanguage int

const (
	CodeBlockLanguageTypescript CodeBlockLanguage = 0
	CodeBlockLanguageCpp        CodeBlockLanguage = 1
	CodeBlockLanguageRuby       CodeBlockLanguage = 2
	CodeBlockLanguageCss        CodeBlockLanguage = 3
	CodeBlockLanguageJavascript CodeBlockLanguage = 4
	CodeBlockLanguageHtml       CodeBlockLanguage = 5
	CodeBlockLanguageJson       CodeBlockLanguage = 6
	CodeBlockLanguageGraphql    CodeBlockLanguage = 7
	CodeBlockLanguagePython     CodeBlockLanguage = 8
	CodeBlockLanguageGo         CodeBlockLanguage = 9
	CodeBlockLanguageSql        CodeBlockLanguage = 10
	CodeBlockLanguageSwift      CodeBlockLanguage = 11
	CodeBlockLanguageKotlin     CodeBlockLanguage = 12
	CodeBlockLanguageRust       CodeBlockLanguage = 13
	CodeBlockLanguageBash       CodeBlockLanguage = 14
	CodeBlockLanguagePlaintext  CodeBlockLanguage = 15
)

type InternalEnumForTest int

const (
	InternalEnumForTestOld InternalEnumForTest = 1
)

type InternalDataForTest struct {
	TestFieldA int `kiwi_index:"1"`
}

func DecodeInternalDataForTest(b *gokiwi.Buffer) (res *InternalDataForTest, err error) {
	res = &InternalDataForTest{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.TestFieldA, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type StateGroupPropertyValueOrder struct {
	Property string   `kiwi_index:"1"`
	Values   []string `kiwi_index:"2"`
}

func DecodeStateGroupPropertyValueOrder(b *gokiwi.Buffer) (res *StateGroupPropertyValueOrder, err error) {
	res = &StateGroupPropertyValueOrder{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Property, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]string, size)
				for i := range size {
					values[i], err = b.ReadString()
					if err != nil {
						return nil, err
					}
				}
				res.Values = values
			}
		}
	}
	return
}

type TextListData struct {
	ListId           int        `kiwi_index:"1"`
	BulletType       BulletType `kiwi_index:"2"`
	IndentationLevel int        `kiwi_index:"3"`
	LineNumber       int        `kiwi_index:"4"`
}

func DecodeTextListData(b *gokiwi.Buffer) (res *TextListData, err error) {
	res = &TextListData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ListId, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.BulletType = BulletType(v)
		case 3:
			res.IndentationLevel, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 4:
			res.LineNumber, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type BulletType int

const (
	BulletTypeOrdered   BulletType = 0
	BulletTypeUnordered BulletType = 1
	BulletTypeIndent    BulletType = 2
	BulletTypeNoList    BulletType = 3
)

type TextLineData struct {
	LineType             LineType             `kiwi_index:"1"`
	StyleId              int                  `kiwi_index:"10"`
	IndentationLevel     int                  `kiwi_index:"2"`
	SourceDirectionality SourceDirectionality `kiwi_index:"9"`
	Directionality       Directionality       `kiwi_index:"3"`
	DirectionalityIntent DirectionalityIntent `kiwi_index:"4"`
	DowngradeStyleId     int                  `kiwi_index:"5"`
	ConsistencyStyleId   int                  `kiwi_index:"6"`
	ListStartOffset      int                  `kiwi_index:"7"`
	IsFirstLineOfList    bool                 `kiwi_index:"8"`
}

func DecodeTextLineData(b *gokiwi.Buffer) (res *TextLineData, err error) {
	res = &TextLineData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.LineType = LineType(v)
		case 10:
			res.StyleId, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 2:
			res.IndentationLevel, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 9:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.SourceDirectionality = SourceDirectionality(v)
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Directionality = Directionality(v)
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.DirectionalityIntent = DirectionalityIntent(v)
		case 5:
			res.DowngradeStyleId, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 6:
			res.ConsistencyStyleId, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 7:
			res.ListStartOffset, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 8:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsFirstLineOfList = v != 0
		}
	}
	return
}

type DerivedTextLineData struct {
	Directionality Directionality `kiwi_index:"1"`
}

func DecodeDerivedTextLineData(b *gokiwi.Buffer) (res *DerivedTextLineData, err error) {
	res = &DerivedTextLineData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Directionality = Directionality(v)
		}
	}
	return
}

type LineType int

const (
	LineTypePlain         LineType = 0
	LineTypeOrderedList   LineType = 1
	LineTypeUnorderedList LineType = 2
	LineTypeBlockquote    LineType = 3
	LineTypeHeader        LineType = 4
)

type SourceDirectionality int

const (
	SourceDirectionalityAuto SourceDirectionality = 0
	SourceDirectionalityLtr  SourceDirectionality = 1
	SourceDirectionalityRtl  SourceDirectionality = 2
)

type Directionality int

const (
	DirectionalityLtr Directionality = 0
	DirectionalityRtl Directionality = 1
)

type DirectionalityIntent int

const (
	DirectionalityIntentImplicit DirectionalityIntent = 0
	DirectionalityIntentExplicit DirectionalityIntent = 1
)

type PrototypeInteraction struct {
	Id                     *GUID              `kiwi_index:"1"`
	Event                  *PrototypeEvent    `kiwi_index:"2"`
	Actions                []*PrototypeAction `kiwi_index:"3"`
	IsDeleted              bool               `kiwi_index:"4"`
	StateManagementVersion int                `kiwi_index:"5"`
}

func DecodePrototypeInteraction(b *gokiwi.Buffer) (res *PrototypeInteraction, err error) {
	res = &PrototypeInteraction{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Event, err = DecodePrototypeEvent(b)
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PrototypeAction, size)
				for i := range size {
					v, err := DecodePrototypeAction(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Actions = values
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsDeleted = v != 0
		case 5:
			res.StateManagementVersion, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PrototypeEvent struct {
	InteractionType       InteractionType `kiwi_index:"1"`
	InteractionMaintained bool            `kiwi_index:"2"`
	InteractionDuration   float64         `kiwi_index:"3"`
	KeyTrigger            *KeyTrigger     `kiwi_index:"4"`
	VoiceEventPhrase      string          `kiwi_index:"5"`
	TransitionTimeout     float64         `kiwi_index:"6"`
	MediaHitTime          float64         `kiwi_index:"7"`
}

func DecodePrototypeEvent(b *gokiwi.Buffer) (res *PrototypeEvent, err error) {
	res = &PrototypeEvent{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.InteractionType = InteractionType(v)
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.InteractionMaintained = v != 0
		case 3:
			res.InteractionDuration, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.KeyTrigger, err = DecodeKeyTrigger(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.VoiceEventPhrase, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 6:
			res.TransitionTimeout, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.MediaHitTime, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PrototypeVariableTarget struct {
	Id             *VariableID     `kiwi_index:"1"`
	NodeFieldAlias *NodeFieldAlias `kiwi_index:"2"`
}

func DecodePrototypeVariableTarget(b *gokiwi.Buffer) (res *PrototypeVariableTarget, err error) {
	res = &PrototypeVariableTarget{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeVariableID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.NodeFieldAlias, err = DecodeNodeFieldAlias(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ConditionalActions struct {
	Actions   []*PrototypeAction `kiwi_index:"1"`
	Condition *VariableData      `kiwi_index:"2"`
}

func DecodeConditionalActions(b *gokiwi.Buffer) (res *ConditionalActions, err error) {
	res = &ConditionalActions{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PrototypeAction, size)
				for i := range size {
					v, err := DecodePrototypeAction(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Actions = values
			}
		case 2:
			res.Condition, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PrototypeAction struct {
	TransitionNodeId                     *GUID                    `kiwi_index:"1"`
	TransitionType                       TransitionType           `kiwi_index:"2"`
	TransitionDuration                   float64                  `kiwi_index:"3"`
	EasingType                           EasingType               `kiwi_index:"4"`
	TransitionTimeout                    float64                  `kiwi_index:"5"`
	TransitionShouldSmartAnimate         bool                     `kiwi_index:"6"`
	ConnectionType                       ConnectionType           `kiwi_index:"7"`
	ConnectionUrl                        string                   `kiwi_index:"8"`
	OverlayRelativePosition              *Vector                  `kiwi_index:"9"`
	NavigationType                       NavigationType           `kiwi_index:"10"`
	TransitionPreserveScroll             bool                     `kiwi_index:"11"`
	EasingFunction                       []float64                `kiwi_index:"12"`
	ExtraScrollOffset                    *Vector                  `kiwi_index:"13"`
	TargetVariableId                     *GUID                    `kiwi_index:"14"`
	TargetVariableValue                  *VariableAnyValue        `kiwi_index:"15"`
	MediaAction                          MediaAction              `kiwi_index:"16"`
	TransitionResetVideoPosition         bool                     `kiwi_index:"17"`
	OpenUrlInNewTab                      bool                     `kiwi_index:"18"`
	TargetVariable                       *PrototypeVariableTarget `kiwi_index:"19"`
	TargetVariableData                   *VariableData            `kiwi_index:"20"`
	MediaSkipToTime                      float64                  `kiwi_index:"21"`
	MediaSkipByAmount                    float64                  `kiwi_index:"22"`
	Conditions                           []*VariableData          `kiwi_index:"23"`
	ConditionalActions                   []*ConditionalActions    `kiwi_index:"24"`
	TransitionResetScrollPosition        bool                     `kiwi_index:"25"`
	TransitionResetInteractiveComponents bool                     `kiwi_index:"26"`
	TargetVariableSetId                  *VariableSetID           `kiwi_index:"27"`
	TargetVariableModeId                 *GUID                    `kiwi_index:"28"`
	TargetVariableSetKey                 string                   `kiwi_index:"29"`
}

func DecodePrototypeAction(b *gokiwi.Buffer) (res *PrototypeAction, err error) {
	res = &PrototypeAction{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.TransitionNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TransitionType = TransitionType(v)
		case 3:
			res.TransitionDuration, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.EasingType = EasingType(v)
		case 5:
			res.TransitionTimeout, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionShouldSmartAnimate = v != 0
		case 7:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ConnectionType = ConnectionType(v)
		case 8:
			res.ConnectionUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 9:
			res.OverlayRelativePosition, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 10:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.NavigationType = NavigationType(v)
		case 11:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionPreserveScroll = v != 0
		case 12:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]float64, size)
				for i := range size {
					values[i], err = b.ReadVarFloat()
					if err != nil {
						return nil, err
					}
				}
				res.EasingFunction = values
			}
		case 13:
			res.ExtraScrollOffset, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 14:
			res.TargetVariableId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 15:
			res.TargetVariableValue, err = DecodeVariableAnyValue(b)
			if err != nil {
				return nil, err
			}
		case 16:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.MediaAction = MediaAction(v)
		case 17:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionResetVideoPosition = v != 0
		case 18:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.OpenUrlInNewTab = v != 0
		case 19:
			res.TargetVariable, err = DecodePrototypeVariableTarget(b)
			if err != nil {
				return nil, err
			}
		case 20:
			res.TargetVariableData, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 21:
			res.MediaSkipToTime, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 22:
			res.MediaSkipByAmount, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 23:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableData, size)
				for i := range size {
					v, err := DecodeVariableData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Conditions = values
			}
		case 24:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ConditionalActions, size)
				for i := range size {
					v, err := DecodeConditionalActions(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ConditionalActions = values
			}
		case 25:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionResetScrollPosition = v != 0
		case 26:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TransitionResetInteractiveComponents = v != 0
		case 27:
			res.TargetVariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		case 28:
			res.TargetVariableModeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 29:
			res.TargetVariableSetKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PrototypeStartingPoint struct {
	Name        string `kiwi_index:"1"`
	Description string `kiwi_index:"2"`
	Position    string `kiwi_index:"3"`
}

func DecodePrototypeStartingPoint(b *gokiwi.Buffer) (res *PrototypeStartingPoint, err error) {
	res = &PrototypeStartingPoint{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Description, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Position, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TriggerDevice int

const (
	TriggerDeviceKeyboard          TriggerDevice = 0
	TriggerDeviceUnknownController TriggerDevice = 1
	TriggerDeviceXboxOne           TriggerDevice = 2
	TriggerDevicePs4               TriggerDevice = 3
	TriggerDeviceSwitchPro         TriggerDevice = 4
)

type KeyTrigger struct {
	KeyCodes      []int         `kiwi_index:"1"`
	TriggerDevice TriggerDevice `kiwi_index:"2"`
}

func DecodeKeyTrigger(b *gokiwi.Buffer) (res *KeyTrigger, err error) {
	res = &KeyTrigger{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]int, size)
				for i := range size {
					values[i], err = b.ReadVarInt()
					if err != nil {
						return nil, err
					}
				}
				res.KeyCodes = values
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.TriggerDevice = TriggerDevice(v)
		}
	}
	return
}

type Hyperlink struct {
	Url  string `kiwi_index:"1"`
	Guid *GUID  `kiwi_index:"2"`
}

func DecodeHyperlink(b *gokiwi.Buffer) (res *Hyperlink, err error) {
	res = &Hyperlink{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Url, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type MentionSource int

const (
	MentionSourceDefault       MentionSource = 0
	MentionSourceCopyDuplicate MentionSource = 1
)

type Mention struct {
	Id                   *GUID         `kiwi_index:"1"`
	MentionedUserId      string        `kiwi_index:"2"`
	MentionedByUserId    string        `kiwi_index:"3"`
	FileKey              string        `kiwi_index:"4"`
	Source               MentionSource `kiwi_index:"5"`
	MentionedUserIdInt   uint64        `kiwi_index:"6"`
	MentionedByUserIdInt uint64        `kiwi_index:"7"`
}

func DecodeMention(b *gokiwi.Buffer) (res *Mention, err error) {
	res = &Mention{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.MentionedUserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.MentionedByUserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.FileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 5:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Source = MentionSource(v)
		case 6:
			res.MentionedUserIdInt, err = b.ReadVarUint64()
			if err != nil {
				return nil, err
			}
		case 7:
			res.MentionedByUserIdInt, err = b.ReadVarUint64()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type EmbedData struct {
	Url                string  `kiwi_index:"1"`
	SrcUrl             string  `kiwi_index:"2"`
	Title              string  `kiwi_index:"3"`
	ThumbnailUrl       string  `kiwi_index:"4"`
	Width              float64 `kiwi_index:"5"`
	Height             float64 `kiwi_index:"6"`
	EmbedType          string  `kiwi_index:"7"`
	ThumbnailImageHash string  `kiwi_index:"8"`
	FaviconImageHash   string  `kiwi_index:"9"`
	Provider           string  `kiwi_index:"10"`
	OriginalText       string  `kiwi_index:"11"`
	Description        string  `kiwi_index:"12"`
	EmbedVersionId     string  `kiwi_index:"13"`
}

func DecodeEmbedData(b *gokiwi.Buffer) (res *EmbedData, err error) {
	res = &EmbedData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Url, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.SrcUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Title, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.ThumbnailUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 5:
			res.Width, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 6:
			res.Height, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 7:
			res.EmbedType, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 8:
			res.ThumbnailImageHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 9:
			res.FaviconImageHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 10:
			res.Provider, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 11:
			res.OriginalText, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 12:
			res.Description, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 13:
			res.EmbedVersionId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type StampData struct {
	UserId          string `kiwi_index:"1"`
	VotingSessionId string `kiwi_index:"2"`
	StampedByUserId string `kiwi_index:"3"`
}

func DecodeStampData(b *gokiwi.Buffer) (res *StampData, err error) {
	res = &StampData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.UserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.VotingSessionId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.StampedByUserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type LinkPreviewData struct {
	Url                  string  `kiwi_index:"1"`
	Title                string  `kiwi_index:"2"`
	Provider             string  `kiwi_index:"3"`
	Description          string  `kiwi_index:"4"`
	ThumbnailImageHash   string  `kiwi_index:"5"`
	FaviconImageHash     string  `kiwi_index:"6"`
	ThumbnailImageWidth  float64 `kiwi_index:"7"`
	ThumbnailImageHeight float64 `kiwi_index:"8"`
}

func DecodeLinkPreviewData(b *gokiwi.Buffer) (res *LinkPreviewData, err error) {
	res = &LinkPreviewData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Url, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Title, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Provider, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.Description, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 5:
			res.ThumbnailImageHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 6:
			res.FaviconImageHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 7:
			res.ThumbnailImageWidth, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 8:
			res.ThumbnailImageHeight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Viewport struct {
	CanvasSpaceBounds *Rect   `kiwi_index:"1"`
	PixelPreview      bool    `kiwi_index:"2"`
	PixelDensity      float64 `kiwi_index:"3"`
	CanvasGuid        *GUID   `kiwi_index:"4"`
}

func DecodeViewport(b *gokiwi.Buffer) (res *Viewport, err error) {
	res = &Viewport{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.CanvasSpaceBounds, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.PixelPreview = v != 0
		case 3:
			res.PixelDensity, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.CanvasGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Mouse struct {
	Cursor                  MouseCursor `kiwi_index:"1"`
	CanvasSpaceLocation     *Vector     `kiwi_index:"2"`
	CanvasSpaceSelectionBox *Rect       `kiwi_index:"3"`
	CanvasGuid              *GUID       `kiwi_index:"4"`
	CursorHiddenReason      uint        `kiwi_index:"5"`
}

func DecodeMouse(b *gokiwi.Buffer) (res *Mouse, err error) {
	res = &Mouse{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Cursor = MouseCursor(v)
		case 2:
			res.CanvasSpaceLocation, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.CanvasSpaceSelectionBox, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.CanvasGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.CursorHiddenReason, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Click struct {
	Id    uint
	Point *Vector
}

func DecodeClick(b *gokiwi.Buffer) (res *Click, err error) {
	res = &Click{}
	res.Id, err = b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	res.Point, err = DecodeVector(b)
	if err != nil {
		return nil, err
	}
	return
}

type ScrollPosition struct {
	Node         *GUID
	ScrollOffset *Vector
}

func DecodeScrollPosition(b *gokiwi.Buffer) (res *ScrollPosition, err error) {
	res = &ScrollPosition{}
	res.Node, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.ScrollOffset, err = DecodeVector(b)
	if err != nil {
		return nil, err
	}
	return
}

type TriggeredOverlay struct {
	OverlayGuid *GUID
	HotspotGuid *GUID
	SwapGuid    *GUID
}

func DecodeTriggeredOverlay(b *gokiwi.Buffer) (res *TriggeredOverlay, err error) {
	res = &TriggeredOverlay{}
	res.OverlayGuid, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.HotspotGuid, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.SwapGuid, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	return
}

type TriggeredOverlayData struct {
	OverlayGuid              *GUID     `kiwi_index:"1"`
	HotspotGuid              *GUID     `kiwi_index:"2"`
	SwapGuid                 *GUID     `kiwi_index:"3"`
	PrototypeInteractionGuid *GUID     `kiwi_index:"4"`
	HotspotBlueprintId       *GUIDPath `kiwi_index:"5"`
}

func DecodeTriggeredOverlayData(b *gokiwi.Buffer) (res *TriggeredOverlayData, err error) {
	res = &TriggeredOverlayData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.OverlayGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.HotspotGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.SwapGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.PrototypeInteractionGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.HotspotBlueprintId, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TriggeredSetVariableActionData struct {
	NodeForFindingTopmostScreenId *GUID  `kiwi_index:"1"`
	TargetVariableId              string `kiwi_index:"2"`
	TargetVariableData            string `kiwi_index:"3"`
	ResolvedVariableModes         string `kiwi_index:"4"`
}

func DecodeTriggeredSetVariableActionData(b *gokiwi.Buffer) (res *TriggeredSetVariableActionData, err error) {
	res = &TriggeredSetVariableActionData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeForFindingTopmostScreenId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.TargetVariableId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.TargetVariableData, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.ResolvedVariableModes, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TriggeredSetVariableModeActionData struct {
	NodeForFindingTopmostScreenId *GUID          `kiwi_index:"1"`
	TargetVariableSetKey          string         `kiwi_index:"2"`
	TargetVariableModeId          string         `kiwi_index:"3"`
	TargetVariableSetId           *VariableSetID `kiwi_index:"4"`
}

func DecodeTriggeredSetVariableModeActionData(b *gokiwi.Buffer) (res *TriggeredSetVariableModeActionData, err error) {
	res = &TriggeredSetVariableModeActionData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeForFindingTopmostScreenId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.TargetVariableSetKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.TargetVariableModeId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.TargetVariableSetId, err = DecodeVariableSetID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VideoStateChangeData struct {
	TargetNodeId         *GUID  `kiwi_index:"1"`
	IsPlaying            bool   `kiwi_index:"2"`
	IsPlayingSound       bool   `kiwi_index:"3"`
	CurrentTimes         []uint `kiwi_index:"4"`
	ActionTakenTimestamp uint   `kiwi_index:"5"`
}

func DecodeVideoStateChangeData(b *gokiwi.Buffer) (res *VideoStateChangeData, err error) {
	res = &VideoStateChangeData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.TargetNodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsPlaying = v != 0
		case 3:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsPlayingSound = v != 0
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.CurrentTimes = values
			}
		case 5:
			res.ActionTakenTimestamp, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type EmbeddedPrototypeData struct {
	NodeId    *GUID `kiwi_index:"1"`
	SessionId uint  `kiwi_index:"2"`
}

func DecodeEmbeddedPrototypeData(b *gokiwi.Buffer) (res *EmbeddedPrototypeData, err error) {
	res = &EmbeddedPrototypeData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PresentedState struct {
	BaseScreenId *GUID                   `kiwi_index:"1"`
	Overlays     []*TriggeredOverlayData `kiwi_index:"2"`
}

func DecodePresentedState(b *gokiwi.Buffer) (res *PresentedState, err error) {
	res = &PresentedState{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.BaseScreenId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TriggeredOverlayData, size)
				for i := range size {
					v, err := DecodeTriggeredOverlayData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Overlays = values
			}
		}
	}
	return
}

type TransitionDirection int

const (
	TransitionDirectionForward TransitionDirection = 0
	TransitionDirectionReverse TransitionDirection = 1
)

type TopLevelPlaybackChange struct {
	OldState                     *PresentedState     `kiwi_index:"1"`
	NewState                     *PresentedState     `kiwi_index:"2"`
	HotspotBlueprintId           *GUIDPath           `kiwi_index:"3"`
	InteractionId                *GUID               `kiwi_index:"4"`
	IsHotspotInNewPresentedState bool                `kiwi_index:"5"`
	Direction                    TransitionDirection `kiwi_index:"6"`
	InstanceStablePath           *GUIDPath           `kiwi_index:"7"`
}

func DecodeTopLevelPlaybackChange(b *gokiwi.Buffer) (res *TopLevelPlaybackChange, err error) {
	res = &TopLevelPlaybackChange{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.OldState, err = DecodePresentedState(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.NewState, err = DecodePresentedState(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.HotspotBlueprintId, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.InteractionId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsHotspotInNewPresentedState = v != 0
		case 6:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Direction = TransitionDirection(v)
		case 7:
			res.InstanceStablePath, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type InstanceStateChange struct {
	StateId            *GUID               `kiwi_index:"1"`
	InteractionId      *GUID               `kiwi_index:"2"`
	HotspotStablePath  *GUIDPath           `kiwi_index:"3"`
	InstanceStablePath *GUIDPath           `kiwi_index:"4"`
	Phase              PlaybackChangePhase `kiwi_index:"5"`
}

func DecodeInstanceStateChange(b *gokiwi.Buffer) (res *InstanceStateChange, err error) {
	res = &InstanceStateChange{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StateId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.InteractionId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.HotspotStablePath, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.InstanceStablePath, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 5:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Phase = PlaybackChangePhase(v)
		}
	}
	return
}

type TextCursor struct {
	SelectionBox *Rect `kiwi_index:"1"`
	CanvasGuid   *GUID `kiwi_index:"2"`
	TextNodeGuid *GUID `kiwi_index:"3"`
}

func DecodeTextCursor(b *gokiwi.Buffer) (res *TextCursor, err error) {
	res = &TextCursor{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SelectionBox, err = DecodeRect(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.CanvasGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.TextNodeGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TextSelection struct {
	SelectionBoxes             []*Rect `kiwi_index:"1"`
	CanvasGuid                 *GUID   `kiwi_index:"2"`
	TextNodeGuid               *GUID   `kiwi_index:"3"`
	TextSelectionRange         *Vector `kiwi_index:"4"`
	TextNodeOrContainingIfGuid *GUID   `kiwi_index:"5"`
	TableCellRowId             *GUID   `kiwi_index:"6"`
	TableCellColId             *GUID   `kiwi_index:"7"`
}

func DecodeTextSelection(b *gokiwi.Buffer) (res *TextSelection, err error) {
	res = &TextSelection{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Rect, size)
				for i := range size {
					v, err := DecodeRect(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.SelectionBoxes = values
			}
		case 2:
			res.CanvasGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.TextNodeGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.TextSelectionRange, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.TextNodeOrContainingIfGuid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.TableCellRowId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 7:
			res.TableCellColId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PlaybackChangePhase int

const (
	PlaybackChangePhaseInitiated PlaybackChangePhase = 0
	PlaybackChangePhaseAborted   PlaybackChangePhase = 1
	PlaybackChangePhaseCommitted PlaybackChangePhase = 2
)

type PlaybackChangeKeyframe struct {
	Phase     PlaybackChangePhase `kiwi_index:"1"`
	Progress  float64             `kiwi_index:"2"`
	Timestamp float64             `kiwi_index:"3"`
}

func DecodePlaybackChangeKeyframe(b *gokiwi.Buffer) (res *PlaybackChangeKeyframe, err error) {
	res = &PlaybackChangeKeyframe{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Phase = PlaybackChangePhase(v)
		case 2:
			res.Progress, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Timestamp, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type StateMapping struct {
	StablePath               *GUIDPath               `kiwi_index:"1"`
	LastTopLevelChange       *TopLevelPlaybackChange `kiwi_index:"2"`
	LastTopLevelChangeStatus *PlaybackChangeKeyframe `kiwi_index:"3"`
	Timestamp                float64                 `kiwi_index:"4"`
}

func DecodeStateMapping(b *gokiwi.Buffer) (res *StateMapping, err error) {
	res = &StateMapping{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StablePath, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.LastTopLevelChange, err = DecodeTopLevelPlaybackChange(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.LastTopLevelChangeStatus, err = DecodePlaybackChangeKeyframe(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.Timestamp, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ScrollMapping struct {
	BlueprintId  *GUIDPath `kiwi_index:"1"`
	OverlayIndex uint      `kiwi_index:"2"`
	ScrollOffset *Vector   `kiwi_index:"3"`
}

func DecodeScrollMapping(b *gokiwi.Buffer) (res *ScrollMapping, err error) {
	res = &ScrollMapping{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.BlueprintId, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.OverlayIndex, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.ScrollOffset, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PlaybackUpdate struct {
	LastTopLevelChange       *TopLevelPlaybackChange `kiwi_index:"1"`
	LastTopLevelChangeStatus *PlaybackChangeKeyframe `kiwi_index:"2"`
	ScrollMappings           []*ScrollMapping        `kiwi_index:"3"`
	Timestamp                float64                 `kiwi_index:"4"`
	PointerLocation          *Vector                 `kiwi_index:"5"`
	IsTopLevelFrameChange    bool                    `kiwi_index:"6"`
	StateMappings            []*StateMapping         `kiwi_index:"7"`
}

func DecodePlaybackUpdate(b *gokiwi.Buffer) (res *PlaybackUpdate, err error) {
	res = &PlaybackUpdate{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.LastTopLevelChange, err = DecodeTopLevelPlaybackChange(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.LastTopLevelChangeStatus, err = DecodePlaybackChangeKeyframe(b)
			if err != nil {
				return nil, err
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ScrollMapping, size)
				for i := range size {
					v, err := DecodeScrollMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ScrollMappings = values
			}
		case 4:
			res.Timestamp, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 5:
			res.PointerLocation, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsTopLevelFrameChange = v != 0
		case 7:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*StateMapping, size)
				for i := range size {
					v, err := DecodeStateMapping(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.StateMappings = values
			}
		}
	}
	return
}

type ChatMessage struct {
	Text         string `kiwi_index:"1"`
	PreviousText string `kiwi_index:"2"`
}

func DecodeChatMessage(b *gokiwi.Buffer) (res *ChatMessage, err error) {
	res = &ChatMessage{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Text, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.PreviousText, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VoiceMetadata struct {
	ConnectedCallId string `kiwi_index:"1"`
}

func DecodeVoiceMetadata(b *gokiwi.Buffer) (res *VoiceMetadata, err error) {
	res = &VoiceMetadata{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ConnectedCallId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AprilFunCursor struct {
	Id           string `kiwi_index:"1"`
	TrailEnabled bool   `kiwi_index:"2"`
}

func DecodeAprilFunCursor(b *gokiwi.Buffer) (res *AprilFunCursor, err error) {
	res = &AprilFunCursor{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.TrailEnabled = v != 0
		}
	}
	return
}

type Heartbeat int

const (
	HeartbeatForeground Heartbeat = 0
	HeartbeatBackground Heartbeat = 1
)

type UserChange struct {
	SessionId                           uint                                  `kiwi_index:"1"`
	Connected                           bool                                  `kiwi_index:"2"`
	Name                                string                                `kiwi_index:"3"`
	Color                               *Color                                `kiwi_index:"4"`
	ImageUrl                            string                                `kiwi_index:"5"`
	Viewport                            *Viewport                             `kiwi_index:"6"`
	Mouse                               *Mouse                                `kiwi_index:"7"`
	Selection                           []*GUID                               `kiwi_index:"8"`
	Observing                           []uint                                `kiwi_index:"9"`
	DeviceName                          string                                `kiwi_index:"10"`
	RecentClicks                        []*Click                              `kiwi_index:"11"`
	ScrollPositions                     []*ScrollPosition                     `kiwi_index:"12"`
	TriggeredOverlays                   []*TriggeredOverlay                   `kiwi_index:"13"`
	UserId                              string                                `kiwi_index:"14"`
	LastTriggeredHotspot                *GUID                                 `kiwi_index:"15"`
	LastTriggeredPrototypeInteractionId *GUID                                 `kiwi_index:"16"`
	TriggeredOverlaysData               []*TriggeredOverlayData               `kiwi_index:"17"`
	PlaybackUpdates                     []*PlaybackUpdate                     `kiwi_index:"18"`
	ChatMessage                         *ChatMessage                          `kiwi_index:"19"`
	VoiceMetadata                       *VoiceMetadata                        `kiwi_index:"20"`
	CanWrite                            bool                                  `kiwi_index:"21"`
	HighFiveStatus                      bool                                  `kiwi_index:"22"`
	InstanceStateChanges                []*InstanceStateChange                `kiwi_index:"23"`
	TextCursor                          *TextCursor                           `kiwi_index:"24"`
	TextSelection                       *TextSelection                        `kiwi_index:"25"`
	ConnectedAtTimeS                    uint                                  `kiwi_index:"26"`
	FocusOnTextCursor                   bool                                  `kiwi_index:"27"`
	Heartbeat                           Heartbeat                             `kiwi_index:"28"`
	TriggeredSetVariableActionData      []*TriggeredSetVariableActionData     `kiwi_index:"29"`
	VideoStateChangeData                []*VideoStateChangeData               `kiwi_index:"30"`
	ClientId                            string                                `kiwi_index:"31"`
	FocusedSlideId                      *GUID                                 `kiwi_index:"32"`
	TriggeredSetVariableModeActionData  []*TriggeredSetVariableModeActionData `kiwi_index:"33"`
	AprilFunCursor                      *AprilFunCursor                       `kiwi_index:"34"`
	EmbeddedPrototypeData               []*EmbeddedPrototypeData              `kiwi_index:"35"`
	ActiveSlidesEmbeddablePrototype     *GUID                                 `kiwi_index:"36"`
}

func DecodeUserChange(b *gokiwi.Buffer) (res *UserChange, err error) {
	res = &UserChange{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Connected = v != 0
		case 3:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.Color, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.ImageUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 6:
			res.Viewport, err = DecodeViewport(b)
			if err != nil {
				return nil, err
			}
		case 7:
			res.Mouse, err = DecodeMouse(b)
			if err != nil {
				return nil, err
			}
		case 8:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Selection = values
			}
		case 9:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.Observing = values
			}
		case 10:
			res.DeviceName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 11:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Click, size)
				for i := range size {
					v, err := DecodeClick(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.RecentClicks = values
			}
		case 12:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ScrollPosition, size)
				for i := range size {
					v, err := DecodeScrollPosition(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ScrollPositions = values
			}
		case 13:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TriggeredOverlay, size)
				for i := range size {
					v, err := DecodeTriggeredOverlay(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.TriggeredOverlays = values
			}
		case 14:
			res.UserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 15:
			res.LastTriggeredHotspot, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 16:
			res.LastTriggeredPrototypeInteractionId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 17:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TriggeredOverlayData, size)
				for i := range size {
					v, err := DecodeTriggeredOverlayData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.TriggeredOverlaysData = values
			}
		case 18:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PlaybackUpdate, size)
				for i := range size {
					v, err := DecodePlaybackUpdate(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PlaybackUpdates = values
			}
		case 19:
			res.ChatMessage, err = DecodeChatMessage(b)
			if err != nil {
				return nil, err
			}
		case 20:
			res.VoiceMetadata, err = DecodeVoiceMetadata(b)
			if err != nil {
				return nil, err
			}
		case 21:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.CanWrite = v != 0
		case 22:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.HighFiveStatus = v != 0
		case 23:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*InstanceStateChange, size)
				for i := range size {
					v, err := DecodeInstanceStateChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.InstanceStateChanges = values
			}
		case 24:
			res.TextCursor, err = DecodeTextCursor(b)
			if err != nil {
				return nil, err
			}
		case 25:
			res.TextSelection, err = DecodeTextSelection(b)
			if err != nil {
				return nil, err
			}
		case 26:
			res.ConnectedAtTimeS, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 27:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.FocusOnTextCursor = v != 0
		case 28:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Heartbeat = Heartbeat(v)
		case 29:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TriggeredSetVariableActionData, size)
				for i := range size {
					v, err := DecodeTriggeredSetVariableActionData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.TriggeredSetVariableActionData = values
			}
		case 30:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VideoStateChangeData, size)
				for i := range size {
					v, err := DecodeVideoStateChangeData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.VideoStateChangeData = values
			}
		case 31:
			res.ClientId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 32:
			res.FocusedSlideId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 33:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*TriggeredSetVariableModeActionData, size)
				for i := range size {
					v, err := DecodeTriggeredSetVariableModeActionData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.TriggeredSetVariableModeActionData = values
			}
		case 34:
			res.AprilFunCursor, err = DecodeAprilFunCursor(b)
			if err != nil {
				return nil, err
			}
		case 35:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*EmbeddedPrototypeData, size)
				for i := range size {
					v, err := DecodeEmbeddedPrototypeData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.EmbeddedPrototypeData = values
			}
		case 36:
			res.ActiveSlidesEmbeddablePrototype, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type InteractiveSlideElementChange struct {
	UserId          string `kiwi_index:"1"`
	AnonymousUserId string `kiwi_index:"2"`
	NodeId          *GUID  `kiwi_index:"3"`
	ResponseData    string `kiwi_index:"4"`
}

func DecodeInteractiveSlideElementChange(b *gokiwi.Buffer) (res *InteractiveSlideElementChange, err error) {
	res = &InteractiveSlideElementChange{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.UserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.AnonymousUserId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.NodeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.ResponseData, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type NodeStatusChange struct {
	NodeIds    []*GUID            `kiwi_index:"1"`
	StatusInfo *SectionStatusInfo `kiwi_index:"2"`
}

func DecodeNodeStatusChange(b *gokiwi.Buffer) (res *NodeStatusChange, err error) {
	res = &NodeStatusChange{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.NodeIds = values
			}
		case 2:
			res.StatusInfo, err = DecodeSectionStatusInfo(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type SceneGraphQueryBehavior int

const (
	SceneGraphQueryBehaviorDefault        SceneGraphQueryBehavior = 0
	SceneGraphQueryBehaviorContainingPage SceneGraphQueryBehavior = 1
	SceneGraphQueryBehaviorPlugin         SceneGraphQueryBehavior = 2
)

type SceneGraphQuery struct {
	StartingNode *GUID                   `kiwi_index:"1"`
	Depth        uint                    `kiwi_index:"2"`
	Behavior     SceneGraphQueryBehavior `kiwi_index:"3"`
}

func DecodeSceneGraphQuery(b *gokiwi.Buffer) (res *SceneGraphQuery, err error) {
	res = &SceneGraphQuery{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StartingNode, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Depth, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Behavior = SceneGraphQueryBehavior(v)
		}
	}
	return
}

type NodeChangesMetadata struct {
	BlobsFieldOffset uint `kiwi_index:"1"`
}

func DecodeNodeChangesMetadata(b *gokiwi.Buffer) (res *NodeChangesMetadata, err error) {
	res = &NodeChangesMetadata{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.BlobsFieldOffset, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type CursorReaction struct {
	ImageUrl string `kiwi_index:"1"`
}

func DecodeCursorReaction(b *gokiwi.Buffer) (res *CursorReaction, err error) {
	res = &CursorReaction{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ImageUrl, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type TimerInfo struct {
	IsPaused                    bool   `kiwi_index:"1"`
	TimeRemainingMs             uint   `kiwi_index:"2"`
	TotalTimeMs                 uint   `kiwi_index:"3"`
	TimerId                     uint   `kiwi_index:"4"`
	SetBy                       string `kiwi_index:"5"`
	SongId                      uint   `kiwi_index:"6"`
	LastReceivedSongTimestampMs uint   `kiwi_index:"7"`
	SongUuid                    string `kiwi_index:"8"`
}

func DecodeTimerInfo(b *gokiwi.Buffer) (res *TimerInfo, err error) {
	res = &TimerInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsPaused = v != 0
		case 2:
			res.TimeRemainingMs, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.TotalTimeMs, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			res.TimerId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 5:
			res.SetBy, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 6:
			res.SongId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 7:
			res.LastReceivedSongTimestampMs, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 8:
			res.SongUuid, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type MusicInfo struct {
	IsPaused                    bool   `kiwi_index:"1"`
	MessageId                   uint   `kiwi_index:"2"`
	SongId                      string `kiwi_index:"3"`
	LastReceivedSongTimestampMs uint   `kiwi_index:"4"`
	IsStopped                   bool   `kiwi_index:"5"`
}

func DecodeMusicInfo(b *gokiwi.Buffer) (res *MusicInfo, err error) {
	res = &MusicInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsPaused = v != 0
		case 2:
			res.MessageId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.SongId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			res.LastReceivedSongTimestampMs, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 5:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsStopped = v != 0
		}
	}
	return
}

type PresenterNomination struct {
	SessionId   uint `kiwi_index:"1"`
	IsCancelled bool `kiwi_index:"2"`
}

func DecodePresenterNomination(b *gokiwi.Buffer) (res *PresenterNomination, err error) {
	res = &PresenterNomination{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsCancelled = v != 0
		}
	}
	return
}

type PresenterInfo struct {
	SessionId  uint                 `kiwi_index:"1"`
	Nomination *PresenterNomination `kiwi_index:"2"`
}

func DecodePresenterInfo(b *gokiwi.Buffer) (res *PresenterInfo, err error) {
	res = &PresenterInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Nomination, err = DecodePresenterNomination(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ClientBroadcast struct {
	SessionId          uint            `kiwi_index:"1"`
	CursorReaction     *CursorReaction `kiwi_index:"2"`
	Timer              *TimerInfo      `kiwi_index:"3"`
	Presenter          *PresenterInfo  `kiwi_index:"4"`
	PrototypePresenter *PresenterInfo  `kiwi_index:"5"`
	Music              *MusicInfo      `kiwi_index:"6"`
}

func DecodeClientBroadcast(b *gokiwi.Buffer) (res *ClientBroadcast, err error) {
	res = &ClientBroadcast{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.CursorReaction, err = DecodeCursorReaction(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.Timer, err = DecodeTimerInfo(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.Presenter, err = DecodePresenterInfo(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.PrototypePresenter, err = DecodePresenterInfo(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.Music, err = DecodeMusicInfo(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type Message struct {
	Type                                  MessageType                    `kiwi_index:"1"`
	SessionId                             uint                           `kiwi_index:"2"`
	AckId                                 uint                           `kiwi_index:"3"`
	NodeChanges                           []*NodeChange                  `kiwi_index:"4"`
	UserChanges                           []*UserChange                  `kiwi_index:"5"`
	InteractiveSlideElementChange         *InteractiveSlideElementChange `kiwi_index:"32"`
	NodeStatusChange                      *NodeStatusChange              `kiwi_index:"36"`
	Blobs                                 []*Blob                        `kiwi_index:"6"`
	BlobBaseIndex                         uint                           `kiwi_index:"30"`
	SignalName                            string                         `kiwi_index:"7"`
	Access                                Access                         `kiwi_index:"8"`
	StyleSetName                          string                         `kiwi_index:"9"`
	StyleSetType                          StyleSetType                   `kiwi_index:"10"`
	StyleSetContentType                   StyleSetContentType            `kiwi_index:"11"`
	PasteId                               int                            `kiwi_index:"12"`
	PasteOffset                           *Vector                        `kiwi_index:"13"`
	PasteFileKey                          string                         `kiwi_index:"14"`
	SignalPayload                         string                         `kiwi_index:"15"`
	SceneGraphQueries                     []*SceneGraphQuery             `kiwi_index:"16"`
	NodeChangesMetadata                   *NodeChangesMetadata           `kiwi_index:"17"`
	FileVersion                           uint                           `kiwi_index:"18"`
	PasteIsPartiallyOutsideEnclosingFrame bool                           `kiwi_index:"19"`
	PastePageId                           *GUID                          `kiwi_index:"20"`
	IsCut                                 bool                           `kiwi_index:"21"`
	LocalUndoStack                        []*Message                     `kiwi_index:"22"`
	LocalRedoStack                        []*Message                     `kiwi_index:"23"`
	Broadcasts                            []*ClientBroadcast             `kiwi_index:"24"`
	ReconnectSequenceNumber               uint                           `kiwi_index:"25"`
	PasteBranchSourceFileKey              string                         `kiwi_index:"26"`
	PasteEditorType                       EditorType                     `kiwi_index:"27"`
	PostSyncActions                       string                         `kiwi_index:"28"`
	PublishedAssetGuids                   []*GUID                        `kiwi_index:"29"`
	DirtyFromInitialLoad                  bool                           `kiwi_index:"31"`
	ClipboardSelectionRegions             []*ClipboardSelectionRegion    `kiwi_index:"33"`
	EncodedOffsetsIndex                   *EncodedOffsetsIndex           `kiwi_index:"34"`
	HasRepeatingContent                   bool                           `kiwi_index:"35"`
}

func DecodeMessage(b *gokiwi.Buffer) (res *Message, err error) {
	res = &Message{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = MessageType(v)
		case 2:
			res.SessionId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.AckId, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.NodeChanges = values
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*UserChange, size)
				for i := range size {
					v, err := DecodeUserChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.UserChanges = values
			}
		case 32:
			res.InteractiveSlideElementChange, err = DecodeInteractiveSlideElementChange(b)
			if err != nil {
				return nil, err
			}
		case 36:
			res.NodeStatusChange, err = DecodeNodeStatusChange(b)
			if err != nil {
				return nil, err
			}
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Blob, size)
				for i := range size {
					v, err := DecodeBlob(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Blobs = values
			}
		case 30:
			res.BlobBaseIndex, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 7:
			res.SignalName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 8:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Access = Access(v)
		case 9:
			res.StyleSetName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 10:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StyleSetType = StyleSetType(v)
		case 11:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.StyleSetContentType = StyleSetContentType(v)
		case 12:
			res.PasteId, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 13:
			res.PasteOffset, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 14:
			res.PasteFileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 15:
			res.SignalPayload, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 16:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*SceneGraphQuery, size)
				for i := range size {
					v, err := DecodeSceneGraphQuery(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.SceneGraphQueries = values
			}
		case 17:
			res.NodeChangesMetadata, err = DecodeNodeChangesMetadata(b)
			if err != nil {
				return nil, err
			}
		case 18:
			res.FileVersion, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 19:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.PasteIsPartiallyOutsideEnclosingFrame = v != 0
		case 20:
			res.PastePageId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 21:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.IsCut = v != 0
		case 22:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Message, size)
				for i := range size {
					v, err := DecodeMessage(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.LocalUndoStack = values
			}
		case 23:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Message, size)
				for i := range size {
					v, err := DecodeMessage(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.LocalRedoStack = values
			}
		case 24:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ClientBroadcast, size)
				for i := range size {
					v, err := DecodeClientBroadcast(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Broadcasts = values
			}
		case 25:
			res.ReconnectSequenceNumber, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 26:
			res.PasteBranchSourceFileKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 27:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.PasteEditorType = EditorType(v)
		case 28:
			res.PostSyncActions, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 29:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PublishedAssetGuids = values
			}
		case 31:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.DirtyFromInitialLoad = v != 0
		case 33:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ClipboardSelectionRegion, size)
				for i := range size {
					v, err := DecodeClipboardSelectionRegion(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ClipboardSelectionRegions = values
			}
		case 34:
			res.EncodedOffsetsIndex, err = DecodeEncodedOffsetsIndex(b)
			if err != nil {
				return nil, err
			}
		case 35:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.HasRepeatingContent = v != 0
		}
	}
	return
}

type EncodedOffsetsIndex struct {
	NodeChangesFieldOffset uint                    `kiwi_index:"1"`
	NodeChangesFieldLength uint                    `kiwi_index:"2"`
	BlobsFieldOffset       uint                    `kiwi_index:"3"`
	NodeChangeOffsets      []*GUIDAndEncodedOffset `kiwi_index:"4"`
}

func DecodeEncodedOffsetsIndex(b *gokiwi.Buffer) (res *EncodedOffsetsIndex, err error) {
	res = &EncodedOffsetsIndex{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.NodeChangesFieldOffset, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			res.NodeChangesFieldLength, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.BlobsFieldOffset, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDAndEncodedOffset, size)
				for i := range size {
					v, err := DecodeGUIDAndEncodedOffset(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.NodeChangeOffsets = values
			}
		}
	}
	return
}

type GUIDAndEncodedOffset struct {
	Guid   *GUID
	Offset uint
}

func DecodeGUIDAndEncodedOffset(b *gokiwi.Buffer) (res *GUIDAndEncodedOffset, err error) {
	res = &GUIDAndEncodedOffset{}
	res.Guid, err = DecodeGUID(b)
	if err != nil {
		return nil, err
	}
	res.Offset, err = b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	return
}

type DiffChunk struct {
	NodeChanges               []uint        `kiwi_index:"1"`
	Phase                     NodePhase     `kiwi_index:"2"`
	DisplayNode               *NodeChange   `kiwi_index:"3"`
	CanvasId                  *GUID         `kiwi_index:"4"`
	CanvasName                string        `kiwi_index:"5"`
	CanvasIsInternal          bool          `kiwi_index:"6"`
	ChunksAffectingThisChunk  []uint        `kiwi_index:"7"`
	BasisParentHierarchy      []*NodeChange `kiwi_index:"8"`
	ParentHierarchy           []*NodeChange `kiwi_index:"9"`
	BasisParentHierarchyGuids []*GUID       `kiwi_index:"10"`
	ParentHierarchyGuids      []*GUID       `kiwi_index:"11"`
}

func DecodeDiffChunk(b *gokiwi.Buffer) (res *DiffChunk, err error) {
	res = &DiffChunk{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.NodeChanges = values
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Phase = NodePhase(v)
		case 3:
			res.DisplayNode, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.CanvasId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.CanvasName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.CanvasIsInternal = v != 0
		case 7:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.ChunksAffectingThisChunk = values
			}
		case 8:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.BasisParentHierarchy = values
			}
		case 9:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ParentHierarchy = values
			}
		case 10:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.BasisParentHierarchyGuids = values
			}
		case 11:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ParentHierarchyGuids = values
			}
		}
	}
	return
}

type DiffPayload struct {
	NodeChanges            []*NodeChange `kiwi_index:"1"`
	Blobs                  []*Blob       `kiwi_index:"2"`
	DiffChunks             []*DiffChunk  `kiwi_index:"3"`
	DiffBasis              []*NodeChange `kiwi_index:"4"`
	BasisParentNodeChanges []*NodeChange `kiwi_index:"5"`
	ParentNodeChanges      []*NodeChange `kiwi_index:"6"`
}

func DecodeDiffPayload(b *gokiwi.Buffer) (res *DiffPayload, err error) {
	res = &DiffPayload{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.NodeChanges = values
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*Blob, size)
				for i := range size {
					v, err := DecodeBlob(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Blobs = values
			}
		case 3:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*DiffChunk, size)
				for i := range size {
					v, err := DecodeDiffChunk(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DiffChunks = values
			}
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.DiffBasis = values
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.BasisParentNodeChanges = values
			}
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeChange, size)
				for i := range size {
					v, err := DecodeNodeChange(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ParentNodeChanges = values
			}
		}
	}
	return
}

type RichMediaType int

const (
	RichMediaTypeAnimatedImage RichMediaType = 0
	RichMediaTypeVideo         RichMediaType = 1
)

type RichMediaData struct {
	MediaHash     string        `kiwi_index:"1"`
	RichMediaType RichMediaType `kiwi_index:"2"`
}

func DecodeRichMediaData(b *gokiwi.Buffer) (res *RichMediaData, err error) {
	res = &RichMediaData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.MediaHash, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.RichMediaType = RichMediaType(v)
		}
	}
	return
}

type VariableDataType int

const (
	VariableDataTypeBoolean        VariableDataType = 0
	VariableDataTypeFloat          VariableDataType = 1
	VariableDataTypeString         VariableDataType = 2
	VariableDataTypeAlias          VariableDataType = 3
	VariableDataTypeColor          VariableDataType = 4
	VariableDataTypeExpression     VariableDataType = 5
	VariableDataTypeMap            VariableDataType = 6
	VariableDataTypeSymbolId       VariableDataType = 7
	VariableDataTypeFontStyle      VariableDataType = 8
	VariableDataTypeTextData       VariableDataType = 9
	VariableDataTypeInvalid        VariableDataType = 10
	VariableDataTypeNodeFieldAlias VariableDataType = 11
)

type VariableResolvedDataType int

const (
	VariableResolvedDataTypeBoolean   VariableResolvedDataType = 0
	VariableResolvedDataTypeFloat     VariableResolvedDataType = 1
	VariableResolvedDataTypeString    VariableResolvedDataType = 2
	VariableResolvedDataTypeColor     VariableResolvedDataType = 4
	VariableResolvedDataTypeMap       VariableResolvedDataType = 5
	VariableResolvedDataTypeSymbolId  VariableResolvedDataType = 6
	VariableResolvedDataTypeFontStyle VariableResolvedDataType = 7
	VariableResolvedDataTypeTextData  VariableResolvedDataType = 8
)

type VariableAnyValue struct {
	BoolValue           bool               `kiwi_index:"1"`
	TextValue           string             `kiwi_index:"2"`
	FloatValue          float64            `kiwi_index:"3"`
	Alias               *VariableID        `kiwi_index:"4"`
	ColorValue          *Color             `kiwi_index:"5"`
	ExpressionValue     *Expression        `kiwi_index:"6"`
	MapValue            *VariableMap       `kiwi_index:"7"`
	SymbolIdValue       *SymbolId          `kiwi_index:"8"`
	FontStyleValue      *VariableFontStyle `kiwi_index:"9"`
	TextDataValue       *TextData          `kiwi_index:"10"`
	NodeFieldAliasValue *NodeFieldAlias    `kiwi_index:"11"`
}

func DecodeVariableAnyValue(b *gokiwi.Buffer) (res *VariableAnyValue, err error) {
	res = &VariableAnyValue{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BoolValue = v != 0
		case 2:
			res.TextValue, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.FloatValue, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.Alias, err = DecodeVariableID(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.ColorValue, err = DecodeColor(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.ExpressionValue, err = DecodeExpression(b)
			if err != nil {
				return nil, err
			}
		case 7:
			res.MapValue, err = DecodeVariableMap(b)
			if err != nil {
				return nil, err
			}
		case 8:
			res.SymbolIdValue, err = DecodeSymbolId(b)
			if err != nil {
				return nil, err
			}
		case 9:
			res.FontStyleValue, err = DecodeVariableFontStyle(b)
			if err != nil {
				return nil, err
			}
		case 10:
			res.TextDataValue, err = DecodeTextData(b)
			if err != nil {
				return nil, err
			}
		case 11:
			res.NodeFieldAliasValue, err = DecodeNodeFieldAlias(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ExpressionFunction int

const (
	ExpressionFunctionAddition           ExpressionFunction = 0
	ExpressionFunctionSubtraction        ExpressionFunction = 1
	ExpressionFunctionResolveVariant     ExpressionFunction = 2
	ExpressionFunctionMultiply           ExpressionFunction = 3
	ExpressionFunctionDivide             ExpressionFunction = 4
	ExpressionFunctionEquals             ExpressionFunction = 5
	ExpressionFunctionNotEqual           ExpressionFunction = 6
	ExpressionFunctionLessThan           ExpressionFunction = 7
	ExpressionFunctionLessThanOrEqual    ExpressionFunction = 8
	ExpressionFunctionGreaterThan        ExpressionFunction = 9
	ExpressionFunctionGreaterThanOrEqual ExpressionFunction = 10
	ExpressionFunctionAnd                ExpressionFunction = 11
	ExpressionFunctionOr                 ExpressionFunction = 12
	ExpressionFunctionNot                ExpressionFunction = 13
	ExpressionFunctionStringify          ExpressionFunction = 14
	ExpressionFunctionTernary            ExpressionFunction = 15
	ExpressionFunctionVarModeLookup      ExpressionFunction = 16
	ExpressionFunctionNegate             ExpressionFunction = 17
	ExpressionFunctionIsTruthy           ExpressionFunction = 18
)

type Expression struct {
	ExpressionFunction  ExpressionFunction `kiwi_index:"1"`
	ExpressionArguments []*VariableData    `kiwi_index:"2"`
}

func DecodeExpression(b *gokiwi.Buffer) (res *Expression, err error) {
	res = &Expression{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ExpressionFunction = ExpressionFunction(v)
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableData, size)
				for i := range size {
					v, err := DecodeVariableData(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.ExpressionArguments = values
			}
		}
	}
	return
}

type VariableMapValue struct {
	Key   string        `kiwi_index:"1"`
	Value *VariableData `kiwi_index:"2"`
}

func DecodeVariableMapValue(b *gokiwi.Buffer) (res *VariableMapValue, err error) {
	res = &VariableMapValue{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Value, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableMap struct {
	Values []*VariableMapValue `kiwi_index:"1"`
}

func DecodeVariableMap(b *gokiwi.Buffer) (res *VariableMap, err error) {
	res = &VariableMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableMapValue, size)
				for i := range size {
					v, err := DecodeVariableMapValue(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Values = values
			}
		}
	}
	return
}

type VariableFontStyle struct {
	AsString     *VariableData `kiwi_index:"1"`
	AsFloat      *VariableData `kiwi_index:"2"`
	AsVariations *VariableData `kiwi_index:"3"`
}

func DecodeVariableFontStyle(b *gokiwi.Buffer) (res *VariableFontStyle, err error) {
	res = &VariableFontStyle{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.AsString, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.AsFloat, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.AsVariations, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type NodeFieldAlias struct {
	StablePathToNode *GUIDPath          `kiwi_index:"1"`
	NodeField        NodeFieldAliasType `kiwi_index:"2"`
	IndexOrKey       string             `kiwi_index:"3"`
}

func DecodeNodeFieldAlias(b *gokiwi.Buffer) (res *NodeFieldAlias, err error) {
	res = &NodeFieldAlias{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.StablePathToNode, err = DecodeGUIDPath(b)
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.NodeField = NodeFieldAliasType(v)
		case 3:
			res.IndexOrKey, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type NodeFieldAliasType int

const (
	NodeFieldAliasTypeMissing                  NodeFieldAliasType = 0
	NodeFieldAliasTypeComponentPropAssignments NodeFieldAliasType = 1
)

type VariableData struct {
	Value            *VariableAnyValue        `kiwi_index:"1"`
	DataType         VariableDataType         `kiwi_index:"2"`
	ResolvedDataType VariableResolvedDataType `kiwi_index:"3"`
}

func DecodeVariableData(b *gokiwi.Buffer) (res *VariableData, err error) {
	res = &VariableData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Value, err = DecodeVariableAnyValue(b)
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.DataType = VariableDataType(v)
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.ResolvedDataType = VariableResolvedDataType(v)
		}
	}
	return
}

type VariableSetMode struct {
	Id           *GUID  `kiwi_index:"1"`
	Name         string `kiwi_index:"2"`
	SortPosition string `kiwi_index:"3"`
}

func DecodeVariableSetMode(b *gokiwi.Buffer) (res *VariableSetMode, err error) {
	res = &VariableSetMode{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Id, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.SortPosition, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableDataValues struct {
	Entries []*VariableDataValuesEntry `kiwi_index:"1"`
}

func DecodeVariableDataValues(b *gokiwi.Buffer) (res *VariableDataValues, err error) {
	res = &VariableDataValues{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*VariableDataValuesEntry, size)
				for i := range size {
					v, err := DecodeVariableDataValuesEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type VariableDataValuesEntry struct {
	ModeId       *GUID         `kiwi_index:"1"`
	VariableData *VariableData `kiwi_index:"2"`
}

func DecodeVariableDataValuesEntry(b *gokiwi.Buffer) (res *VariableDataValuesEntry, err error) {
	res = &VariableDataValuesEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ModeId, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.VariableData, err = DecodeVariableData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableScope int

const (
	VariableScopeAllScopes        VariableScope = 0
	VariableScopeTextContent      VariableScope = 1
	VariableScopeCornerRadius     VariableScope = 2
	VariableScopeWidthHeight      VariableScope = 3
	VariableScopeGap              VariableScope = 4
	VariableScopeAllFills         VariableScope = 5
	VariableScopeFrameFill        VariableScope = 6
	VariableScopeShapeFill        VariableScope = 7
	VariableScopeTextFill         VariableScope = 8
	VariableScopeStroke           VariableScope = 9
	VariableScopeStrokeFloat      VariableScope = 10
	VariableScopeEffectFloat      VariableScope = 11
	VariableScopeEffectColor      VariableScope = 12
	VariableScopeOpacity          VariableScope = 13
	VariableScopeFontStyle        VariableScope = 14
	VariableScopeFontFamily       VariableScope = 15
	VariableScopeFontSize         VariableScope = 16
	VariableScopeLineHeight       VariableScope = 17
	VariableScopeLetterSpacing    VariableScope = 18
	VariableScopeParagraphSpacing VariableScope = 19
	VariableScopeParagraphIndent  VariableScope = 20
	VariableScopeFontVariations   VariableScope = 21
)

type CodeSyntaxPlatform int

const (
	CodeSyntaxPlatformWeb     CodeSyntaxPlatform = 0
	CodeSyntaxPlatformAndroid CodeSyntaxPlatform = 1
	CodeSyntaxPlatformIOs     CodeSyntaxPlatform = 2
)

type OptionalVector struct {
	Value *Vector `kiwi_index:"1"`
}

func DecodeOptionalVector(b *gokiwi.Buffer) (res *OptionalVector, err error) {
	res = &OptionalVector{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Value, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type HTMLTag int

const (
	HTMLTagAuto       HTMLTag = 0
	HTMLTagArticle    HTMLTag = 1
	HTMLTagSection    HTMLTag = 2
	HTMLTagNav        HTMLTag = 3
	HTMLTagAside      HTMLTag = 4
	HTMLTagH1         HTMLTag = 5
	HTMLTagH2         HTMLTag = 6
	HTMLTagH3         HTMLTag = 7
	HTMLTagH4         HTMLTag = 8
	HTMLTagH5         HTMLTag = 9
	HTMLTagH6         HTMLTag = 10
	HTMLTagHgroup     HTMLTag = 11
	HTMLTagHeader     HTMLTag = 12
	HTMLTagFooter     HTMLTag = 13
	HTMLTagAddress    HTMLTag = 14
	HTMLTagP          HTMLTag = 15
	HTMLTagHr         HTMLTag = 16
	HTMLTagPre        HTMLTag = 17
	HTMLTagBlockquote HTMLTag = 18
	HTMLTagOl         HTMLTag = 19
	HTMLTagUl         HTMLTag = 20
	HTMLTagMenu       HTMLTag = 21
	HTMLTagLi         HTMLTag = 22
	HTMLTagDl         HTMLTag = 23
	HTMLTagDt         HTMLTag = 24
	HTMLTagDd         HTMLTag = 25
	HTMLTagFigure     HTMLTag = 26
	HTMLTagFigcaption HTMLTag = 27
	HTMLTagMain       HTMLTag = 28
	HTMLTagDiv        HTMLTag = 29
	HTMLTagA          HTMLTag = 30
	HTMLTagEm         HTMLTag = 31
	HTMLTagStrong     HTMLTag = 32
	HTMLTagSmall      HTMLTag = 33
	HTMLTagS          HTMLTag = 34
	HTMLTagCite       HTMLTag = 35
	HTMLTagQ          HTMLTag = 36
	HTMLTagDfn        HTMLTag = 37
	HTMLTagAbbr       HTMLTag = 38
	HTMLTagRuby       HTMLTag = 39
	HTMLTagRt         HTMLTag = 40
	HTMLTagRp         HTMLTag = 41
	HTMLTagData       HTMLTag = 42
	HTMLTagTime       HTMLTag = 43
	HTMLTagCode       HTMLTag = 44
	HTMLTagVar        HTMLTag = 45
	HTMLTagSamp       HTMLTag = 46
	HTMLTagKbd        HTMLTag = 47
	HTMLTagSub        HTMLTag = 48
	HTMLTagSup        HTMLTag = 49
	HTMLTagI          HTMLTag = 50
	HTMLTagB          HTMLTag = 51
	HTMLTagU          HTMLTag = 52
	HTMLTagMark       HTMLTag = 53
	HTMLTagBdi        HTMLTag = 54
	HTMLTagBdo        HTMLTag = 55
	HTMLTagSpan       HTMLTag = 56
	HTMLTagBr         HTMLTag = 57
	HTMLTagWbr        HTMLTag = 58
	HTMLTagPicture    HTMLTag = 59
	HTMLTagSource     HTMLTag = 60
	HTMLTagImg        HTMLTag = 61
	HTMLTagForm       HTMLTag = 62
	HTMLTagLabel      HTMLTag = 63
	HTMLTagInput      HTMLTag = 64
	HTMLTagButton     HTMLTag = 65
	HTMLTagSelect     HTMLTag = 66
	HTMLTagDatalist   HTMLTag = 67
	HTMLTagOptgroup   HTMLTag = 68
	HTMLTagOption     HTMLTag = 69
	HTMLTagTextarea   HTMLTag = 70
	HTMLTagOutput     HTMLTag = 71
	HTMLTagProgress   HTMLTag = 72
	HTMLTagMeter      HTMLTag = 73
	HTMLTagFieldset   HTMLTag = 74
	HTMLTagLegend     HTMLTag = 75
	HTMLTagVideo      HTMLTag = 76
)

type ARIARole int

const (
	ARIARoleAuto             ARIARole = 0
	ARIARoleNone             ARIARole = 52
	ARIARoleApplication      ARIARole = 30
	ARIARoleBanner           ARIARole = 67
	ARIARoleComplementary    ARIARole = 68
	ARIARoleContentinfo      ARIARole = 69
	ARIARoleForm             ARIARole = 70
	ARIARoleMain             ARIARole = 71
	ARIARoleNavigation       ARIARole = 72
	ARIARoleRegion           ARIARole = 73
	ARIARoleSearch           ARIARole = 74
	ARIARoleSeparator        ARIARole = 13
	ARIARoleArticle          ARIARole = 31
	ARIARoleColumnheader     ARIARole = 35
	ARIARoleDefinition       ARIARole = 36
	ARIARoleDirectory        ARIARole = 38
	ARIARoleDocument         ARIARole = 39
	ARIARoleGroup            ARIARole = 44
	ARIARoleHeading          ARIARole = 45
	ARIARoleImg              ARIARole = 46
	ARIARoleList             ARIARole = 48
	ARIARoleListitem         ARIARole = 49
	ARIARoleMath             ARIARole = 50
	ARIARoleNote             ARIARole = 53
	ARIARolePresentation     ARIARole = 55
	ARIARoleRow              ARIARole = 56
	ARIARoleRowgroup         ARIARole = 57
	ARIARoleRowheader        ARIARole = 58
	ARIARoleTable            ARIARole = 62
	ARIARoleToolbar          ARIARole = 65
	ARIARoleButton           ARIARole = 1
	ARIARoleCheckbox         ARIARole = 2
	ARIARoleGridcell         ARIARole = 3
	ARIARoleLink             ARIARole = 4
	ARIARoleMenuitem         ARIARole = 5
	ARIARoleMenuitemcheckbox ARIARole = 6
	ARIARoleMenuitemradio    ARIARole = 7
	ARIARoleOption           ARIARole = 8
	ARIARoleProgressbar      ARIARole = 9
	ARIARoleRadio            ARIARole = 10
	ARIARoleScrollbar        ARIARole = 11
	ARIARoleSlider           ARIARole = 14
	ARIARoleSpinbutton       ARIARole = 15
	ARIARoleTab              ARIARole = 17
	ARIARoleTabpanel         ARIARole = 18
	ARIARoleTextbox          ARIARole = 19
	ARIARoleTreeitem         ARIARole = 20
	ARIARoleCombobox         ARIARole = 21
	ARIARoleGrid             ARIARole = 22
	ARIARoleListbox          ARIARole = 23
	ARIARoleMenu             ARIARole = 24
	ARIARoleMenubar          ARIARole = 25
	ARIARoleRadiogroup       ARIARole = 26
	ARIARoleTablist          ARIARole = 27
	ARIARoleTree             ARIARole = 28
	ARIARoleTreegrid         ARIARole = 29
	ARIARoleTooltip          ARIARole = 66
	ARIARoleAlert            ARIARole = 75
	ARIARoleLog              ARIARole = 76
	ARIARoleMarquee          ARIARole = 77
	ARIARoleStatus           ARIARole = 78
	ARIARoleTimer            ARIARole = 79
	ARIARoleAlertdialog      ARIARole = 80
	ARIARoleDialog           ARIARole = 81
	ARIARoleSearchbox        ARIARole = 12
	ARIARoleSwitch           ARIARole = 16
	ARIARoleBlockquote       ARIARole = 32
	ARIARoleCaption          ARIARole = 33
	ARIARoleCell             ARIARole = 34
	ARIARoleDeletion         ARIARole = 37
	ARIARoleEmphasis         ARIARole = 40
	ARIARoleFeed             ARIARole = 41
	ARIARoleFigure           ARIARole = 42
	ARIARoleGeneric          ARIARole = 43
	ARIARoleInsertion        ARIARole = 47
	ARIARoleMeter            ARIARole = 51
	ARIARoleParagraph        ARIARole = 54
	ARIARoleStrong           ARIARole = 59
	ARIARoleSubscript        ARIARole = 60
	ARIARoleSuperscript      ARIARole = 61
	ARIARoleTerm             ARIARole = 63
	ARIARoleTime             ARIARole = 64
	ARIARoleImage            ARIARole = 82
	ARIARoleHeading1         ARIARole = 83
	ARIARoleHeading2         ARIARole = 84
	ARIARoleHeading3         ARIARole = 85
	ARIARoleHeading4         ARIARole = 86
	ARIARoleHeading5         ARIARole = 87
	ARIARoleHeading6         ARIARole = 88
	ARIARoleHeader           ARIARole = 89
	ARIARoleFooter           ARIARole = 90
	ARIARoleSidebar          ARIARole = 91
	ARIARoleSection          ARIARole = 92
	ARIARoleMaincontent      ARIARole = 93
	ARIARoleTableCell        ARIARole = 94
	ARIARoleWidget           ARIARole = 95
)

type MigrationStatus struct {
	DsdCleanup bool `kiwi_index:"1"`
}

func DecodeMigrationStatus(b *gokiwi.Buffer) (res *MigrationStatus, err error) {
	res = &MigrationStatus{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.DsdCleanup = v != 0
		}
	}
	return
}

type NodeFieldMap struct {
	Entries []*NodeFieldMapEntry `kiwi_index:"1"`
}

func DecodeNodeFieldMap(b *gokiwi.Buffer) (res *NodeFieldMap, err error) {
	res = &NodeFieldMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*NodeFieldMapEntry, size)
				for i := range size {
					v, err := DecodeNodeFieldMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type NodeFieldMapEntry struct {
	Guid                       *GUID `kiwi_index:"1"`
	Field                      uint  `kiwi_index:"2"`
	LastModifiedSequenceNumber uint  `kiwi_index:"3"`
}

func DecodeNodeFieldMapEntry(b *gokiwi.Buffer) (res *NodeFieldMapEntry, err error) {
	res = &NodeFieldMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Field, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.LastModifiedSequenceNumber, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ColorProfile int

const (
	ColorProfileSrgb      ColorProfile = 0
	ColorProfileDisplayP3 ColorProfile = 1
)

type DocumentColorProfile int

const (
	DocumentColorProfileLegacy    DocumentColorProfile = 0
	DocumentColorProfileSrgb      DocumentColorProfile = 1
	DocumentColorProfileDisplayP3 DocumentColorProfile = 2
)

type ChildReadingDirection int

const (
	ChildReadingDirectionNone        ChildReadingDirection = 0
	ChildReadingDirectionLeftToRight ChildReadingDirection = 1
	ChildReadingDirectionRightToLeft ChildReadingDirection = 2
)

type ARIAAttributeAnyValue struct {
	BoolValue        bool     `kiwi_index:"1"`
	StringValue      string   `kiwi_index:"2"`
	FloatValue       float64  `kiwi_index:"3"`
	IntValue         int      `kiwi_index:"4"`
	StringArrayValue []string `kiwi_index:"5"`
}

func DecodeARIAAttributeAnyValue(b *gokiwi.Buffer) (res *ARIAAttributeAnyValue, err error) {
	res = &ARIAAttributeAnyValue{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.BoolValue = v != 0
		case 2:
			res.StringValue, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.FloatValue, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.IntValue, err = b.ReadVarInt()
			if err != nil {
				return nil, err
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]string, size)
				for i := range size {
					values[i], err = b.ReadString()
					if err != nil {
						return nil, err
					}
				}
				res.StringArrayValue = values
			}
		}
	}
	return
}

type ARIAAttributeDataType int

const (
	ARIAAttributeDataTypeBoolean    ARIAAttributeDataType = 0
	ARIAAttributeDataTypeString     ARIAAttributeDataType = 1
	ARIAAttributeDataTypeFloat      ARIAAttributeDataType = 2
	ARIAAttributeDataTypeInt        ARIAAttributeDataType = 3
	ARIAAttributeDataTypeStringList ARIAAttributeDataType = 4
)

type ARIAAttributeData struct {
	Type  ARIAAttributeDataType  `kiwi_index:"1"`
	Value *ARIAAttributeAnyValue `kiwi_index:"2"`
}

func DecodeARIAAttributeData(b *gokiwi.Buffer) (res *ARIAAttributeData, err error) {
	res = &ARIAAttributeData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = ARIAAttributeDataType(v)
		case 2:
			res.Value, err = DecodeARIAAttributeAnyValue(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ARIAAttributesMap struct {
	Entries []*ARIAAttributesMapEntry `kiwi_index:"1"`
}

func DecodeARIAAttributesMap(b *gokiwi.Buffer) (res *ARIAAttributesMap, err error) {
	res = &ARIAAttributesMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*ARIAAttributesMapEntry, size)
				for i := range size {
					v, err := DecodeARIAAttributesMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type ARIAAttributesMapEntry struct {
	Attribute string             `kiwi_index:"1"`
	Value     *ARIAAttributeData `kiwi_index:"2"`
}

func DecodeARIAAttributesMapEntry(b *gokiwi.Buffer) (res *ARIAAttributesMapEntry, err error) {
	res = &ARIAAttributesMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Attribute, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Value, err = DecodeARIAAttributeData(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type HandoffStatusMapEntry struct {
	Guid          *GUID              `kiwi_index:"1"`
	HandoffStatus *SectionStatusInfo `kiwi_index:"2"`
}

func DecodeHandoffStatusMapEntry(b *gokiwi.Buffer) (res *HandoffStatusMapEntry, err error) {
	res = &HandoffStatusMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Guid, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.HandoffStatus, err = DecodeSectionStatusInfo(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type HandoffStatusMap struct {
	Entries []*HandoffStatusMapEntry `kiwi_index:"1"`
}

func DecodeHandoffStatusMap(b *gokiwi.Buffer) (res *HandoffStatusMap, err error) {
	res = &HandoffStatusMap{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*HandoffStatusMapEntry, size)
				for i := range size {
					v, err := DecodeHandoffStatusMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Entries = values
			}
		}
	}
	return
}

type EditScopeInfo struct {
	EditScopeStacks []*EditScopeStack    `kiwi_index:"1"`
	Snapshots       []*EditScopeSnapshot `kiwi_index:"2"`
}

func DecodeEditScopeInfo(b *gokiwi.Buffer) (res *EditScopeInfo, err error) {
	res = &EditScopeInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*EditScopeStack, size)
				for i := range size {
					v, err := DecodeEditScopeStack(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.EditScopeStacks = values
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*EditScopeSnapshot, size)
				for i := range size {
					v, err := DecodeEditScopeSnapshot(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Snapshots = values
			}
		}
	}
	return
}

type EditScopeSnapshot struct {
	Frames                 []*EditScopeStack `kiwi_index:"1"`
	NodeChangeFieldNumbers []uint            `kiwi_index:"2"`
}

func DecodeEditScopeSnapshot(b *gokiwi.Buffer) (res *EditScopeSnapshot, err error) {
	res = &EditScopeSnapshot{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*EditScopeStack, size)
				for i := range size {
					v, err := DecodeEditScopeStack(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Frames = values
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]uint, size)
				for i := range size {
					values[i], err = b.ReadVarUint()
					if err != nil {
						return nil, err
					}
				}
				res.NodeChangeFieldNumbers = values
			}
		}
	}
	return
}

type EditScopeStack struct {
	Stack []*EditScope `kiwi_index:"1"`
}

func DecodeEditScopeStack(b *gokiwi.Buffer) (res *EditScopeStack, err error) {
	res = &EditScopeStack{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*EditScope, size)
				for i := range size {
					v, err := DecodeEditScope(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Stack = values
			}
		}
	}
	return
}

type EditScope struct {
	Type       EditScopeType `kiwi_index:"1"`
	Label      string        `kiwi_index:"2"`
	EditorType EditorType    `kiwi_index:"3"`
}

func DecodeEditScope(b *gokiwi.Buffer) (res *EditScope, err error) {
	res = &EditScope{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = EditScopeType(v)
		case 2:
			res.Label, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.EditorType = EditorType(v)
		}
	}
	return
}

type EditScopeType int

const (
	EditScopeTypeInvalid    EditScopeType = 0
	EditScopeTypeTestSetup  EditScopeType = 1
	EditScopeTypeUser       EditScopeType = 2
	EditScopeTypePlugin     EditScopeType = 3
	EditScopeTypeSystem     EditScopeType = 4
	EditScopeTypeRestApi    EditScopeType = 5
	EditScopeTypeOnboarding EditScopeType = 6
	EditScopeTypeAutosave   EditScopeType = 7
	EditScopeTypeAi         EditScopeType = 8
)

type SectionPresetState int

const (
	SectionPresetStateInserted   SectionPresetState = 0
	SectionPresetStateUserEdited SectionPresetState = 1
)

type EmojiImageSet int

const (
	EmojiImageSetApple EmojiImageSet = 0
	EmojiImageSetNoto  EmojiImageSet = 1
)

type SectionPresetInfo struct {
	ShelfId      uint64             `kiwi_index:"1"`
	TemplateId   uint64             `kiwi_index:"2"`
	TemplateName string             `kiwi_index:"3"`
	State        SectionPresetState `kiwi_index:"4"`
}

func DecodeSectionPresetInfo(b *gokiwi.Buffer) (res *SectionPresetInfo, err error) {
	res = &SectionPresetInfo{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.ShelfId, err = b.ReadVarUint64()
			if err != nil {
				return nil, err
			}
		case 2:
			res.TemplateId, err = b.ReadVarUint64()
			if err != nil {
				return nil, err
			}
		case 3:
			res.TemplateName, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.State = SectionPresetState(v)
		}
	}
	return
}

type ClipboardSelectionRegion struct {
	Parent                                *GUID   `kiwi_index:"1"`
	Nodes                                 []*GUID `kiwi_index:"2"`
	EnclosingFrameOffset                  *Vector `kiwi_index:"3"`
	PasteIsPartiallyOutsideEnclosingFrame bool    `kiwi_index:"4"`
}

func DecodeClipboardSelectionRegion(b *gokiwi.Buffer) (res *ClipboardSelectionRegion, err error) {
	res = &ClipboardSelectionRegion{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Parent, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUID, size)
				for i := range size {
					v, err := DecodeGUID(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Nodes = values
			}
		case 3:
			res.EnclosingFrameOffset, err = DecodeVector(b)
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.PasteIsPartiallyOutsideEnclosingFrame = v != 0
		}
	}
	return
}

type FirstDraftKitType int

const (
	FirstDraftKitTypeLocal   FirstDraftKitType = 0
	FirstDraftKitTypeLibrary FirstDraftKitType = 1
	FirstDraftKitTypeNone    FirstDraftKitType = 2
)

type FirstDraftKit struct {
	Key  string            `kiwi_index:"1"`
	Type FirstDraftKitType `kiwi_index:"2"`
}

func DecodeFirstDraftKit(b *gokiwi.Buffer) (res *FirstDraftKit, err error) {
	res = &FirstDraftKit{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Key, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = FirstDraftKitType(v)
		}
	}
	return
}

type FirstDraftData struct {
	GenerationId string         `kiwi_index:"1"`
	Kit          *FirstDraftKit `kiwi_index:"2"`
}

func DecodeFirstDraftData(b *gokiwi.Buffer) (res *FirstDraftData, err error) {
	res = &FirstDraftData{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.GenerationId, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Kit, err = DecodeFirstDraftKit(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PlatformShapeProperty int

const (
	PlatformShapePropertyFill   PlatformShapeProperty = 0
	PlatformShapePropertyStroke PlatformShapeProperty = 1
	PlatformShapePropertyText   PlatformShapeProperty = 2
)

type PlatformShapePropertyMapEntry struct {
	Property  PlatformShapeProperty `kiwi_index:"1"`
	NodePaths []*GUIDPath           `kiwi_index:"2"`
}

func DecodePlatformShapePropertyMapEntry(b *gokiwi.Buffer) (res *PlatformShapePropertyMapEntry, err error) {
	res = &PlatformShapePropertyMapEntry{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Property = PlatformShapeProperty(v)
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*GUIDPath, size)
				for i := range size {
					v, err := DecodeGUIDPath(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.NodePaths = values
			}
		}
	}
	return
}

type PlatformShapeDefinition struct {
	PropertyMapEntries []*PlatformShapePropertyMapEntry `kiwi_index:"1"`
}

func DecodePlatformShapeDefinition(b *gokiwi.Buffer) (res *PlatformShapeDefinition, err error) {
	res = &PlatformShapeDefinition{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*PlatformShapePropertyMapEntry, size)
				for i := range size {
					v, err := DecodePlatformShapePropertyMapEntry(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.PropertyMapEntries = values
			}
		}
	}
	return
}

type NodeBehaviors struct {
	Link            *LinkBehavior            `kiwi_index:"1"`
	Appear          *AppearBehavior          `kiwi_index:"2"`
	Hover           *HoverBehavior           `kiwi_index:"3"`
	Press           *PressBehavior           `kiwi_index:"4"`
	Focus           *FocusBehavior           `kiwi_index:"5"`
	ScrollParallax  *ScrollParallaxBehavior  `kiwi_index:"6"`
	ScrollTransform *ScrollTransformBehavior `kiwi_index:"7"`
}

func DecodeNodeBehaviors(b *gokiwi.Buffer) (res *NodeBehaviors, err error) {
	res = &NodeBehaviors{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Link, err = DecodeLinkBehavior(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.Appear, err = DecodeAppearBehavior(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.Hover, err = DecodeHoverBehavior(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.Press, err = DecodePressBehavior(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.Focus, err = DecodeFocusBehavior(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.ScrollParallax, err = DecodeScrollParallaxBehavior(b)
			if err != nil {
				return nil, err
			}
		case 7:
			res.ScrollTransform, err = DecodeScrollTransformBehavior(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type BehaviorTransition struct {
	EasingType         EasingType `kiwi_index:"1"`
	EasingFunction     []float64  `kiwi_index:"2"`
	TransitionDuration float64    `kiwi_index:"3"`
	Delay              float64    `kiwi_index:"4"`
}

func DecodeBehaviorTransition(b *gokiwi.Buffer) (res *BehaviorTransition, err error) {
	res = &BehaviorTransition{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.EasingType = EasingType(v)
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]float64, size)
				for i := range size {
					values[i], err = b.ReadVarFloat()
					if err != nil {
						return nil, err
					}
				}
				res.EasingFunction = values
			}
		case 3:
			res.TransitionDuration, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			res.Delay, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type AppearBehaviorTrigger int

const (
	AppearBehaviorTriggerPageLoad         AppearBehaviorTrigger = 1
	AppearBehaviorTriggerThisLayerInView  AppearBehaviorTrigger = 2
	AppearBehaviorTriggerOtherLayerInView AppearBehaviorTrigger = 3
	AppearBehaviorTriggerScrollDirection  AppearBehaviorTrigger = 4
)

type RelativeDirection int

const (
	RelativeDirectionUp    RelativeDirection = 1
	RelativeDirectionDown  RelativeDirection = 2
	RelativeDirectionLeft  RelativeDirection = 3
	RelativeDirectionRight RelativeDirection = 4
)

type LinkBehaviorType int

const (
	LinkBehaviorTypeUrl  LinkBehaviorType = 1
	LinkBehaviorTypePage LinkBehaviorType = 2
)

type LinkBehavior struct {
	Type            LinkBehaviorType `kiwi_index:"1"`
	Url             string           `kiwi_index:"2"`
	Page            *GUID            `kiwi_index:"3"`
	OpenInNewWindow bool             `kiwi_index:"4"`
}

func DecodeLinkBehavior(b *gokiwi.Buffer) (res *LinkBehavior, err error) {
	res = &LinkBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Type = LinkBehaviorType(v)
		case 2:
			res.Url, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Page, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.OpenInNewWindow = v != 0
		}
	}
	return
}

type AppearBehavior struct {
	Trigger         AppearBehaviorTrigger `kiwi_index:"1"`
	Direction       RelativeDirection     `kiwi_index:"2"`
	OtherLayer      *GUID                 `kiwi_index:"3"`
	EnterTransition *BehaviorTransition   `kiwi_index:"4"`
	EnterState      *NodeChange           `kiwi_index:"5"`
	ExitTransition  *BehaviorTransition   `kiwi_index:"6"`
	ExitState       *NodeChange           `kiwi_index:"7"`
	PlaysOnce       bool                  `kiwi_index:"8"`
}

func DecodeAppearBehavior(b *gokiwi.Buffer) (res *AppearBehavior, err error) {
	res = &AppearBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Trigger = AppearBehaviorTrigger(v)
		case 2:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Direction = RelativeDirection(v)
		case 3:
			res.OtherLayer, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.EnterTransition, err = DecodeBehaviorTransition(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.EnterState, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		case 6:
			res.ExitTransition, err = DecodeBehaviorTransition(b)
			if err != nil {
				return nil, err
			}
		case 7:
			res.ExitState, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		case 8:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.PlaysOnce = v != 0
		}
	}
	return
}

type HoverBehavior struct {
	Transition *BehaviorTransition `kiwi_index:"1"`
	State      *NodeChange         `kiwi_index:"2"`
}

func DecodeHoverBehavior(b *gokiwi.Buffer) (res *HoverBehavior, err error) {
	res = &HoverBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Transition, err = DecodeBehaviorTransition(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.State, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type PressBehavior struct {
	Transition *BehaviorTransition `kiwi_index:"1"`
	State      *NodeChange         `kiwi_index:"2"`
}

func DecodePressBehavior(b *gokiwi.Buffer) (res *PressBehavior, err error) {
	res = &PressBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Transition, err = DecodeBehaviorTransition(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.State, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type FocusBehavior struct {
	Transition *BehaviorTransition `kiwi_index:"1"`
	State      *NodeChange         `kiwi_index:"2"`
}

func DecodeFocusBehavior(b *gokiwi.Buffer) (res *FocusBehavior, err error) {
	res = &FocusBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Transition, err = DecodeBehaviorTransition(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.State, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type ScrollParallaxBehavior struct {
	Axis           ScrollDirection `kiwi_index:"1"`
	Speed          float64         `kiwi_index:"2"`
	RelativeToPage bool            `kiwi_index:"3"`
}

func DecodeScrollParallaxBehavior(b *gokiwi.Buffer) (res *ScrollParallaxBehavior, err error) {
	res = &ScrollParallaxBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Axis = ScrollDirection(v)
		case 2:
			res.Speed, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 3:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.RelativeToPage = v != 0
		}
	}
	return
}

type ScrollTransformBehaviorTrigger int

const (
	ScrollTransformBehaviorTriggerPageHeight       ScrollTransformBehaviorTrigger = 1
	ScrollTransformBehaviorTriggerThisLayerInView  ScrollTransformBehaviorTrigger = 2
	ScrollTransformBehaviorTriggerOtherLayerInView ScrollTransformBehaviorTrigger = 3
)

type ScrollTransformBehavior struct {
	Trigger    ScrollTransformBehaviorTrigger `kiwi_index:"1"`
	OtherLayer *GUID                          `kiwi_index:"2"`
	Transition *BehaviorTransition            `kiwi_index:"3"`
	FromState  *NodeChange                    `kiwi_index:"4"`
	ToState    *NodeChange                    `kiwi_index:"5"`
}

func DecodeScrollTransformBehavior(b *gokiwi.Buffer) (res *ScrollTransformBehavior, err error) {
	res = &ScrollTransformBehavior{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			v, err := b.ReadVarUint()
			if err != nil {
				return nil, err
			}
			res.Trigger = ScrollTransformBehaviorTrigger(v)
		case 2:
			res.OtherLayer, err = DecodeGUID(b)
			if err != nil {
				return nil, err
			}
		case 3:
			res.Transition, err = DecodeBehaviorTransition(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.FromState, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		case 5:
			res.ToState, err = DecodeNodeChange(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type VariableIdOrVariableOverrideId struct {
	VariableId         *VariableID         `kiwi_index:"1"`
	VariableOverrideId *VariableOverrideId `kiwi_index:"2"`
}

func DecodeVariableIdOrVariableOverrideId(b *gokiwi.Buffer) (res *VariableIdOrVariableOverrideId, err error) {
	res = &VariableIdOrVariableOverrideId{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.VariableId, err = DecodeVariableID(b)
			if err != nil {
				return nil, err
			}
		case 2:
			res.VariableOverrideId, err = DecodeVariableOverrideId(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}

type IndexFontVariationAxis struct {
	Tag          string
	Name         string
	Min          float64
	Max          float64
	DefaultValue float64
}

func DecodeIndexFontVariationAxis(b *gokiwi.Buffer) (res *IndexFontVariationAxis, err error) {
	res = &IndexFontVariationAxis{}
	res.Tag, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.Name, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.Min, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.Max, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	res.DefaultValue, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type IndexFontVariationAxisValue struct {
	Tag   string
	Value float64
}

func DecodeIndexFontVariationAxisValue(b *gokiwi.Buffer) (res *IndexFontVariationAxisValue, err error) {
	res = &IndexFontVariationAxisValue{}
	res.Tag, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.Value, err = b.ReadVarFloat()
	if err != nil {
		return nil, err
	}
	return
}

type IndexFontStyle struct {
	Name                string                         `kiwi_index:"1"`
	Postscript          string                         `kiwi_index:"2"`
	Weight              float64                        `kiwi_index:"3"`
	Italic              bool                           `kiwi_index:"4"`
	Stretch             float64                        `kiwi_index:"5"`
	VariationAxisValues []*IndexFontVariationAxisValue `kiwi_index:"6"`
}

func DecodeIndexFontStyle(b *gokiwi.Buffer) (res *IndexFontStyle, err error) {
	res = &IndexFontStyle{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Name, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Postscript, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Weight, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 4:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.Italic = v != 0
		case 5:
			res.Stretch, err = b.ReadVarFloat()
			if err != nil {
				return nil, err
			}
		case 6:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*IndexFontVariationAxisValue, size)
				for i := range size {
					v, err := DecodeIndexFontVariationAxisValue(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.VariationAxisValues = values
			}
		}
	}
	return
}

type IndexFontFile struct {
	Filename           string                    `kiwi_index:"1"`
	Version            uint                      `kiwi_index:"2"`
	Family             string                    `kiwi_index:"3"`
	Styles             []*IndexFontStyle         `kiwi_index:"4"`
	VariationAxes      []*IndexFontVariationAxis `kiwi_index:"5"`
	UseFontOpticalSize bool                      `kiwi_index:"6"`
}

func DecodeIndexFontFile(b *gokiwi.Buffer) (res *IndexFontFile, err error) {
	res = &IndexFontFile{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.Filename, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 2:
			res.Version, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 3:
			res.Family, err = b.ReadString()
			if err != nil {
				return nil, err
			}
		case 4:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*IndexFontStyle, size)
				for i := range size {
					v, err := DecodeIndexFontStyle(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Styles = values
			}
		case 5:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*IndexFontVariationAxis, size)
				for i := range size {
					v, err := DecodeIndexFontVariationAxis(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.VariationAxes = values
			}
		case 6:
			v, err := b.ReadByte()
			if err != nil {
				return nil, err
			}
			res.UseFontOpticalSize = v != 0
		}
	}
	return
}

type IndexFamilyRename struct {
	OldFamily string
	NewFamily string
}

func DecodeIndexFamilyRename(b *gokiwi.Buffer) (res *IndexFamilyRename, err error) {
	res = &IndexFamilyRename{}
	res.OldFamily, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.NewFamily, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	return
}

type IndexStyleRename struct {
	OldStyle string
	NewStyle string
}

func DecodeIndexStyleRename(b *gokiwi.Buffer) (res *IndexStyleRename, err error) {
	res = &IndexStyleRename{}
	res.OldStyle, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	res.NewStyle, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	return
}

type IndexFamilyStylesRename struct {
	FamilyName   string
	StyleRenames []*IndexStyleRename
}

func DecodeIndexFamilyStylesRename(b *gokiwi.Buffer) (res *IndexFamilyStylesRename, err error) {
	res = &IndexFamilyStylesRename{}
	res.FamilyName, err = b.ReadString()
	if err != nil {
		return nil, err
	}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]*IndexStyleRename, size)
		for i := range size {
			v, err := DecodeIndexStyleRename(b)
			if err != nil {
				return nil, err
			}
			values[i] = v
		}
		res.StyleRenames = values
	}
	return
}

type IndexRenames struct {
	Family []*IndexFamilyRename
	Style  []*IndexFamilyStylesRename
}

func DecodeIndexRenames(b *gokiwi.Buffer) (res *IndexRenames, err error) {
	res = &IndexRenames{}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]*IndexFamilyRename, size)
		for i := range size {
			v, err := DecodeIndexFamilyRename(b)
			if err != nil {
				return nil, err
			}
			values[i] = v
		}
		res.Family = values
	}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]*IndexFamilyStylesRename, size)
		for i := range size {
			v, err := DecodeIndexFamilyStylesRename(b)
			if err != nil {
				return nil, err
			}
			values[i] = v
		}
		res.Style = values
	}
	return
}

type IndexEmojiSequence struct {
	Codepoints []uint
}

func DecodeIndexEmojiSequence(b *gokiwi.Buffer) (res *IndexEmojiSequence, err error) {
	res = &IndexEmojiSequence{}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]uint, size)
		for i := range size {
			values[i], err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
		res.Codepoints = values
	}
	return
}

type IndexEmojis struct {
	Revision  uint
	Sizes     []uint
	Sequences []*IndexEmojiSequence
}

func DecodeIndexEmojis(b *gokiwi.Buffer) (res *IndexEmojis, err error) {
	res = &IndexEmojis{}
	res.Revision, err = b.ReadVarUint()
	if err != nil {
		return nil, err
	}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]uint, size)
		for i := range size {
			values[i], err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		}
		res.Sizes = values
	}
	{
		size, err := b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		values := make([]*IndexEmojiSequence, size)
		for i := range size {
			v, err := DecodeIndexEmojiSequence(b)
			if err != nil {
				return nil, err
			}
			values[i] = v
		}
		res.Sequences = values
	}
	return
}

type FontIndex struct {
	SchemaVersion uint             `kiwi_index:"1"`
	Files         []*IndexFontFile `kiwi_index:"2"`
	Renames       *IndexRenames    `kiwi_index:"3"`
	Emojis        *IndexEmojis     `kiwi_index:"4"`
}

func DecodeFontIndex(b *gokiwi.Buffer) (res *FontIndex, err error) {
	res = &FontIndex{}
	var idx uint

loop:
	for {
		idx, err = b.ReadVarUint()
		if err != nil {
			return nil, err
		}
		switch idx {
		case 0:
			break loop
		case 1:
			res.SchemaVersion, err = b.ReadVarUint()
			if err != nil {
				return nil, err
			}
		case 2:
			{
				size, err := b.ReadVarUint()
				if err != nil {
					return nil, err
				}
				values := make([]*IndexFontFile, size)
				for i := range size {
					v, err := DecodeIndexFontFile(b)
					if err != nil {
						return nil, err
					}
					values[i] = v
				}
				res.Files = values
			}
		case 3:
			res.Renames, err = DecodeIndexRenames(b)
			if err != nil {
				return nil, err
			}
		case 4:
			res.Emojis, err = DecodeIndexEmojis(b)
			if err != nil {
				return nil, err
			}
		}
	}
	return
}
